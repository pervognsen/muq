#! /usr/bin/perl

######################## muq-byacc-to-muf ########################
# Quick hack to convert byacc output to MUF input readable by Muq.
#
# 99Aug25 CrT: Created
##################################################################

# Open input file:
open(IN,"y.tab.c") || die "Couldn't open y.tab.c: $!\n";

# Write header of output file:
print <<'endofheader'
@c --- This file is formatted for outline-minor-mode in emacs19.  Do:
@c -^C^O^A to show All of file.
@c  ^C^O^Q to Quickfold entire file. (Leaves only top-level headings.)
@c  ^C^O^T to hide all Text. (Leaves all headings.)
@c  ^C^O^I to show Immediate children of node.
@c  ^C^O^S to Show all of a node.
@c  ^C^O^D to hiDe all of a node.
@c  ^HFoutline-mode for more details.
@c  (Or do ^HI and read emacs:outline mode.)
@example  @c

( This file automatically generated by muq-byacc-to-muf.  )

( ======================================================= )
( DO NOT EDIT THIS FILE unless you'll willing to risk all )
( your changes being lost in the next build. Edit the     )
( corresponding .y file instead.                          )
( ======================================================= )

"MUC" rootValidateDbfile pop
[ "muc" .db["MUC"] | ]inPackage
me$s.lib["muc"] --> .lib["muc"]

endofheader
;



# Discard first three lines, which look like
# #ifndef lint
# static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
# #endif
$line = <IN>;
$line = <IN>;
$line = <IN>;

# Discard next seven lines, which look like
# #define YYBYACC 1
# #define YYMAJOR 1
# #define YYMINOR 9
# #define yyclearin (yychar=(-1))
# #define yyerrok (yyerrflag=0)
# #define YYRECOVERING (yyerrflag!=0)
# #define YYPREFIX "yy"
$line = <IN>;
$line = <IN>;
$line = <IN>;
$line = <IN>;
$line = <IN>;
$line = <IN>;
$line = <IN>;

# Read the following set of defines, which look like:
# #define AUTO 257
# #define BREAK 258
# ...
while ($line = <IN>) {
    if ($line =~ /^#define ([_A-Z]+) ([0-9]+)$/) {
	printf("%s -->constant %s\n",$2,$1);
    } else { last; }
}



# Now parse the yylhs array:
@yylhs = ();
if ($line =~ /^short yylhs\[\] \= \{\s*([^,]+)\,$/) {
    push(@yylhs,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yylhs,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yylhs\n",$#yylhs+1);
for ($i = 0; $i <= $#yylhs; ++$i) {
    printf(" %4d --> _yylhs[%d]\n",$yylhs[$i],$i);
}



# ... and the yylen array:
@yylen = ();
$line = <IN>;
if ($line =~ /^short yylen\[\] \= \{\s*([^,]+)\,$/) {
    push(@yylen,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yylen,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yylen\n",$#yylen+1);
for ($i = 0; $i <= $#yylen; ++$i) {
    printf(" %4d --> _yylen[%d]\n",$yylen[$i],$i);
}



# ... and the yydefred array:
@yydefred = ();
$line = <IN>;
if ($line =~ /^short yydefred\[\] \= \{\s*([^,]+)\,$/) {
    push(@yydefred,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yydefred,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yydefred\n",$#yydefred+1);
for ($i = 0; $i <= $#yydefred; ++$i) {
    printf(" %4d --> _yydefred[%d]\n",$yydefred[$i],$i);
}



# ... and the yydgoto array:
@yydgoto = ();
$line = <IN>;
if ($line =~ /^short yydgoto\[\] \= \{\s*([^,]+)\,$/) {
    push(@yydgoto,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yydgoto,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yydgoto\n",$#yydgoto+1);
for ($i = 0; $i <= $#yydgoto; ++$i) {
    printf(" %4d --> _yydgoto[%d]\n",$yydgoto[$i],$i);
}



# ... and the yysindex array:
@yysindex = ();
$line = <IN>;
if ($line =~ /^short yysindex\[\] \= \{\s*([^,]+)\,$/) {
    push(@yysindex,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yysindex,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yysindex\n",$#yysindex+1);
for ($i = 0; $i <= $#yysindex; ++$i) {
    printf(" %4d --> _yysindex[%d]\n",$yysindex[$i],$i);
}



# ... and the yyrindex array:
@yyrindex = ();
$line = <IN>;
if ($line =~ /^short yyrindex\[\] \= \{\s*([^,]+)\,$/) {
    push(@yyrindex,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yyrindex,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yyrindex\n",$#yyrindex+1);
for ($i = 0; $i <= $#yyrindex; ++$i) {
    printf(" %4d --> _yyrindex[%d]\n",$yyrindex[$i],$i);
}



# ... and the yygindex array:
@yygindex = ();
$line = <IN>;
if ($line =~ /^short yygindex\[\] \= \{\s*([^,]+)\,$/) {
    push(@yygindex,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yygindex,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yygindex\n",$#yygindex+1);
for ($i = 0; $i <= $#yygindex; ++$i) {
    printf(" %4d --> _yygindex[%d]\n",$yygindex[$i],$i);
}



# Now a #define looking like
# #define YYTABLESIZE 1379
$line = <IN>;
if ($line =~ /^#define YYTABLESIZE ([0-9]+)$/) {
    printf("\n$1 -->constant YYTABLESIZE\n");
}



# Now read the yytable[] array:
@yytable = ();
$line = <IN>;
if ($line =~ /^short yytable\[\] \= \{\s*([^,]+)\,$/) {
    push(@yytable,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yytable,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yytable\n",$#yytable+1);
for ($i = 0; $i <= $#yytable; ++$i) {
    printf(" %4d --> _yytable[%d]\n",$yytable[$i],$i);
}



# ... and the yycheck array:
@yycheck = ();
$line = <IN>;
if ($line =~ /^short yycheck\[\] \= \{\s*([^,]+)\,$/) {
    push(@yycheck,$1);
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	while ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
            push(@yycheck,$1);
	    $line = $2;
	}
    }
}
printf("\n0 %s makeVectorI16 --> _yycheck\n",$#yycheck+1);
for ($i = 0; $i <= $#yycheck; ++$i) {
    printf(" %4d --> _yycheck[%d]\n",$yycheck[$i],$i);
}



# Now a #define looking like
# #define YYFINAL 28
$line = <IN>;
if ($line =~ /^#define YYFINAL ([0-9]+)$/) {
    printf("\n$1 -->constant YYFINAL\n");
}



# Skip three lines looking like
# #ifndef YYDEBUG
# #define YYDEBUG 0
# #endif
$line = <IN>;
$line = <IN>;
$line = <IN>;



# Now a #define looking like
# #define YYMAXTOKEN 318
$line = <IN>;
if ($line =~ /^#define YYMAXTOKEN ([0-9]+)$/) {
    printf("\n$1 -->constant YYMAXTOKEN\n");
}



# Skip a line looking like
# #if YYDEBUG
$line = <IN>;



# Now for an array looking like
# char *yyname[] = {
# "end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# ...
# "STAR_SET","SUBSUB","SUB_SET",
# };
@yyname = ();
$line = <IN>;
if ($line =~ /^char \*yyname\[\] \= \{$/) {
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
	for (;;) {
	    if ($line =~ /^\s*([-0-9]+)\,(.*)$/) {
                push(@yyname,$1);
	        $line = $2;
	    } elsif ($line =~ /^\s*(\"[^\"]+\")\,(.*)$/) {
                push(@yyname,$1);
	        $line = $2;
	    } else { last; }
	}
    }
}
printf("\n0 %s makeVector --> _yyname\n",$#yyname+1);
for ($i = 0; $i <= $#yyname; ++$i) {
    printf(" %s --> _yyname[%d]\n",$yyname[$i],$i);
}




# And now an array looking like
# char *yyrule[] = {
# "$accept : statement",
# "atom : ID",
# ...
# "statements : statements statement",
# };
@yyrule = ();
$line = <IN>;
if ($line =~ /^char \*yyrule\[\] \= \{$/) {
    while ($line = <IN>) {
	if ($line eq "};\n") { last; }
        if ($line =~ /^\s*(\".+\")\,$/) {
            push(@yyrule,$1);
	}
    }
}
printf("\n0 %s makeVector --> _yyrule\n",$#yyrule+1);
for ($i = 0; $i <= $#yyrule; ++$i) {
    printf(" %s --> _yyrule[%d]\n",$yyrule[$i],$i);
}



# Now ignore some lines looking like
# #endif
# #ifndef YYSTYPE
# typedef int YYSTYPE;
# #endif
# #ifdef YYSTACKSIZE
# #undef YYMAXDEPTH
# #define YYMAXDEPTH YYSTACKSIZE
# #else
# #ifdef YYMAXDEPTH
# #define YYSTACKSIZE YYMAXDEPTH
# #else
# #define YYSTACKSIZE 500
# #define YYMAXDEPTH 500
# #endif
# #endif
# int yydebug;
# int yynerrs;
# int yyerrflag;
# int yychar;
# short *yyssp;
# YYSTYPE *yyvsp;
# YYSTYPE yyval;
# YYSTYPE yylval;
# short yyss[YYSTACKSIZE];
# YYSTYPE yyvs[YYSTACKSIZE];
# #define yystacksize YYSTACKSIZE
# #line 223 "muc.y"
while ($line = <IN>) {
    if ($line =~ /^\#line/) { last; }
}


# Now save all text up until the next #line -- this will be
# the hand-coded support code supplied by the user:
@usercode = ();
while ($line = <IN>) {
    if ($line =~ /^\#line/) { last; }
    push(@usercode,$line);
}



# Write to output the global variable declarations needed
# by the action functions generated from user actions on
# the grammar rules:
print <<'endofglobals'



( Global variables used by the actions: )
makeStack --> _yyss    ( State stack -- central data structure.   )
makeStack --> _yyvs    ( Value stack, parallel to state stack.    )
nil       --> _yyval   ( ACTIONS put rule value in this variable. )
nil       --> _yylval  ( LEXER puts token value in this variable. )
nil       --> _yydebug ( Set true for vebose logging of parsing.  )

'_yydebug export

endofglobals
;

# Now write out the user-supplied MUF code:
for ($i = 0; $i <= $#usercode; ++$i) {
    print $usercode[$i];
}



# ... finally, the action array.  Actions are buried in the
# code in blocks looking like:
#   case 4:
#   #line 90 "muc.y"
#   { printf("const: INT_CNST\n"); }
printf("\n0 %s makeVector --> _yyaction\n",$#yytable+1);
while ($line = <IN>) {
    if ($line =~ /^case ([0-9]+)\:$/) {
	$actno = $1;
        $line = <IN>;
        if ($line =~ /^\#line [0-9]+ \".*\"$/) {
            $line = <IN>;
            if ($line =~ /^\{ \"(.+)\"\; \}$/) {
		$action = $1;
		$action =~ s/\\\"/\"/g;
		$action =~ s/\$\$/@.yyval/g;
		$action =~ s/\$1/@.yyvs\[-1\]/g;
		$action =~ s/\$2/@.yyvs\[-2\]/g;
		$action =~ s/\$3/@.yyvs\[-3\]/g;
		$action =~ s/\$4/@.yyvs\[-4\]/g;
		$action =~ s/\$5/@.yyvs\[-5\]/g;
		$action =~ s/\$6/@.yyvs\[-6\]/g;
		$action =~ s/\$7/@.yyvs\[-7\]/g;
		$action =~ s/\$8/@.yyvs\[-8\]/g;
		$action =~ s/\$9/@.yyvs\[-9\]/g;
		print "  :: $action ;   \t--> _yyaction[$actno]\n";
	    }
	}
    }
}



# Finally, write out MUF-coded yyparse function:
print <<'endofyyparse'

:   yyparse { -> $ }

    0 -> yym
    0 -> yyn
    0 -> yystate

    0 -> yynerrs
    0 -> yyerrflag
   -1 -> yychar
    0 -> yylast

    0 @.yyss push

    do{   ( yyloop )
	@.yydefred[yystate] -> yyn
	yyn 0 = if

	    ( Maybe read next token: )
	    yychar 0 < if
		yylast yylex -> yychar     yychar -> yylast
		yychar 0 < if 0 -> yychar fi
	    fi

	    @.yydebug if
		yychar @.YYMAXTOKEN < if
		    @.yyname[yychar] -> yys
		    yys 0 = if "illegal-symbol" -> yys" fi
		    [ "yydebug: state %d reading %d (%s)\n" yystate yychar yys | ]print ,
		fi
	    fi

	    ( Maybe shift to new state: )
	    @.yysindex[yystate] -> yyn
	    yyn 0 != if
		yyn yychar + -> yyn
		yyn 0 >= if
		    yyn @.YYTABLESIZE <= if
		        @.yycheck[yyn] yychar = if

			    @.yydebug if
				[   "yydebug: state %d shifting to state %d\n"
				    yystate @.yytable[yyn]
				| ]print ,
			    fi

			    ( Yes, shift to new state: )
			    @.yytable[yyn] -> yystate
                            yystate @.yyss push
			    @.yylval @.yyvs push

			    -1 -> yychar

			    yyerrflag 0 > if -- yyerrflag fi

			    loopNext   ( yyloop )
		        fi
		    fi
		fi
	    fi

            @.yyrindex[yystate] -> yyn
            yyn yychar + -> yym
	    yyn 0 !=
	    yym 0 >=               and
	    yym @.YYTABLESIZE <=   and
	    @.yycheck[yym] yychar = and if
		@.yytable[yym] -> yyn
	    else
		yyerrflag 0 = if
		    "syntax error" yyerror
		    ++ yynerrs
		fi
		yyerrflag 3 < if
		    3 -> yyerrflag
		    do{
			@.yyss[-1]      -> yym
                        @.yysindex[yym] -> yyn
                        yyn YYERRCODE + -> yym
			yyn 0 !=
			yym 0 >=                  and
			yym @.YYTABLESIZE <=      and
			@.yycheck[yym] YYERRCODE = and if
			    @.yydebug if
				[   "yydebug: state %d, error recovery shifting to state %d\n"
				    @.yyss[-1] @.yytable[yyn]
				| ]print ,
			    fi
			    yym -> yyn
			    @.yytable[yyn] -> yystate
                            yystate @.yyss push
			    @.yylval @.yyvs push
			    loopFinish
			else
			    @.yydebug if
				[   "yydebug: error recovery discarding state %d\n"
				    @.yyss[-1]
				| ]print ,
			    fi
			    @.yyss$s.length 0 = if 1 return fi  ( abort )
			    @.yyss pull pop
			    @.yyvs pull pop
			fi
		    }
		    loopNext
		else
		    yychar 0 = if 1 return fi ( abort )
		    @.yydebug if
			0 -> yys
			yychar @.YYMAXTOKEN <= if @.yyname[yychar] -> yys fi
			yys 0 = if "illegal-symbol" -> yys fi
			[   "yydebug: state %d error recovery discards token %d (%s)\n"
			    yystate yychar yys
			| ]print ,
		    fi
		    -1 -> yychar
		    loopNext  ( yyloop )
		fi
	    fi
        fi

        ( Reduce: )
	@.yylen[yyn] -> yym
        yym neg -> i
	@.yyvs[i] --> @.yyval
	@.yyaction[yyn] 0 != if @.yyaction[yyn] call{ -> } fi
	@.yydebug if
	    [   "yydebug: state %d reducing by rule %d (%s) yyval=%s\n"
		yystate yyn @.yyrule[yyn] @.yyval
	    | ]print , 
	    @.yyaction[yyn] 0 != if
		[   "yydebug: @.yyaction[%d] == %s\n"
		    yyn @.yyaction[yyn]
		| ]print , 
	    fi 
	fi
        for i from 0 below yym do{
	    @.yyss pull pop
	    @.yyvs pull pop
        }
        @.yyss[-1]   -> yystate
        @.yylhs[yyn] -> yym

        yystate 0 =   yym 0 =   and if
	    @.yydebug if
	        [   "yydebug: after reduction, shifting from state 0 to state %d\n"
		    @.YYFINAL
		| ]print ,
	    fi
	    @.YYFINAL -> yystate
	    @.YYFINAL @.yyss push
	    @.yyval  @.yyvs push
	    yychar 0 < if
		yylast yylex -> yychar    yychar -> yylast
		yychar 0 < if   0 -> yychar   fi
		@.yydebug if
		    0 -> yys
		    yychar @.YYMAXTOKEN <= if @.yyname[yychar] -> yys fi
		    yys 0 = if "illegal-symbol" -> yys fi
		    [   "yydebug: state %d, reading %d (%s)\n"
			@.YYFINAL yychar yys
		    | ]print ,
		fi
	    fi
	    yychar 0 = if   0 return   fi   ( accept )
	else
	    @.yygindex[yym] -> yyn
            yyn yystate + -> yyn2
	    yyn2 0 != 
	    yyn2 0 >=                  and
	    yyn2 @.YYTABLESIZE <=      and if
	        @.yycheck[yyn2] yystate =  if
		    yyn2 -> yyn
		    @.yytable[yyn] -> yystate
		else
		    @.yydgoto[yym] -> yystate
	        fi
	    else
		@.yydgoto[yym] -> yystate
	    fi
	    @.yydebug if
		[   "yydebug: after reduction, shifting from state %d to state %d\n"
		    @.yyss[-1] yystate
		| ]print ,
	    fi
	    yystate @.yyss push
	    @.yyval @.yyvs push
        fi
    }   ( yyloop )
;


( =====================================================================	)

( - File variables							)


( Local variables:							)
( mode: outline-minor							)
( outline-regexp: "( -+"						)
( End:									)

@end example
endofyyparse
;
