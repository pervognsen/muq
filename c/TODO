/************************************************************************/
/*-    TODO								*/
/************************************************************************/

Various notes to myself (Cynbe) on work in progress or coming up.

There's currently lots more worklist stuff at the top of muq/c/vm.t

-> Do we really need the is_a taking up 8 bytes in every compiled
   function...?

-> I think maybe each guest should have its own db.  Doing otherwise
   will make it hard to keep track of ownership properly, which in
   turn is likely to make for security bugs.  Which in turn sounds
   like over-optimization.
     This does however suggest that for efficiency perhaps the 'db'
   notion should be divorced from the 'Disk Allocation Tableset'
   notion:  If we factored the allocation stuff out of a Vm_Db record
   into a separate record, then several dbs could share a single
   DAT record -- in particular, all the GEST dbs should be able
   to share a single DAT record, without pain.
     Should this hack be visible in the API?
     What happens when such a DB is exported and then imported again?
     Does the .db file format need to record the parent DAT?
     If so, what serves as a DAT ID?
   Or is factoring out the DAT also over-optimization?  How much space
   will it actually save us, typically?  How hard would it be to
   convert over to a factored-DAT representation post-beta?
    



/************************************************************************/
/*-    UNRESOLVED BUG REPORTS						*/
/************************************************************************/

SCOT CROSBY:

Another noticed thing when I try running without the dbase in the
current
directory. It does successfully create the muq-RUNNING-* files there,
but:
>>>>
[crosby@hypercube crosby]$ muq muq/muq-db-1.45/Current/muq
Opening db ROOTDB...
Opening db KEYW...
Opening db MUF...
Opening db LISP...
Opening db QNET...
Opening db DBUG...
Opening db DIFI...
Opening db GEST...
Opening db LNED...
Opening db MUC...
Opening db MUFV...
Opening db QNETA...
Opening db TLNT...
Opening db muqn...
***** Couldn't create 'muq-muq/muq-db-1.45/Current/muq.pid',
continuing
anyhow.
Segmentation fault

Finally, once I cd into the directory and start'er up, it boots and
seems
to function, though I notice the oldmud stuff is no longer on the
``root configuration menu''.

He also suggests:
    I'm pretty good at that. and IMO, your distribution design somewhat
    stinks. Its like you're copying 90% of your muq devel environment and
    expecting people to use it as is. Perhaps use the autoconf '--prefix'
    feature and hardcode the user's chosen path into the scripts that need
    it?
    (And hardcodes the build directory into the scripts needed for
    building)
    Throw in the ability of chosing and running a db in another directory
    (that which tickled the bug), and its I'd like the distribution.




    The condition restart is broken from a remote connection.
    >>>>
    foo:
    1
    foo: 1
    2
    foo: 1 2
    +
    foo: 3
    +
    <<<<
    If I do this from a user logged in remotely (either root, or a normal
    user), there is no response, and MUQ spins, sucking up all CPU until
    the
    user disconnects. (and the job is killed)
     owner    jobPid   jobSet   session  # stacksiz opsDone  queues
     -------- -------- -------- -------- - -------- -------- --------
     foo      17       17       16       1 512      132      i/o
     foo      20       20       20       1 8192     4710132  run
     foo      21       21       20       1 512      200      i/o
    Using the console directly, it works.
    >>>>
    root:
    1
    root: 1
    2
    root: 1 2
    +
    root: 3
    +
    Sorry: Stack underflow
    root:
    <<<<
    Scott




/************************************************************************/
/*-    IN PROGRESS -- HARDCODE						*/
/************************************************************************/

*  Currently setting up I01 vectors.

*  Currently adding ARY class: Need to add it to mod.t (two places),
   obj[2?].h, Makefile2.in, then add commands to make and test for
   it parallel to makeVector (I suppose).


/************************************************************************/
/*-    IN PROGRESS -- SOFTCODE						*/
/************************************************************************/

*  Currently implementing '@eject <name>' which kicks object/avatar
   out of room.  Must outrank them or own room -- can leave 'outrank' for postbeta.
   Kicked avatar should be notified to do an '@home' (in effect) so it isn't left
   hanging in an odd state.  Naturally, it should verify message is from owner of
   current room before implementing it!

*  Currently implementing @boot <name>=<reason> which logs someone off.
   Must outrank them.

*  Currently implementing @tunnel command to connect two pre-existing
   rooms.  Probably should track every room created by a user in
   a per-user db.  That will make both jumping to an arbitrary room
   easy, and also the @connect.  An @note command could add other
   rooms to the db.  Make sure db can later support get-/drop-able
   vanilla objects also.

*  Currently implementing @undig and @untunnel.

/************************************************************************/
/*-    SHOULD BE DONE PRE-BETA						*/
/************************************************************************/

*  GCC-HOWTO-4.html notes some problems with interruptable system
   calls (should probably carefully comb through vm.t and skt.t
   (in particular) to see if there is anything that needs fixing):

	    POSIX systems check for signals a bit more often than some older
	    unices. Linux may execute signal handlers --- 

		   asynchronously (at a timer tick) 
		   on return from any system call 
		   during the execution of the following system calls: select(),
	    pause(), connect(), accept(), read() on terminals, sockets,
		   pipes or files in /proc, write() on terminals, sockets, pipes
	    or the line printer, open() on FIFOs, PTYs or serial lines, ioctl()
		   on terminals, fcntl() with command F_SETLKW, wait4(), syslog(),
	    any TCP or NFS operations. 

	    For other operating systems you may have to include the system calls
	    creat(), close(), getmsg(), putmsg(), msgrcv(), msgsnd(),
	    recv(), send(), wait(), waitpid(), wait3(), tcdrain(), sigpause(),
	    semop() to this list. 

	    If a signal (that the program has installed a handler for) occurs
	    during a system call, the handler is called. When the handler returns
	    (to
	    the system call) it detects that it was interrupted, and immediately
	    returns with -1 and errno = EINTR. The program is not expecting
	    that to happen, so bottles out. 

	    You may choose between two fixes. 

	    (1) For every signal handler that you install, add SA_RESTART to the
	    sigaction flags. For example, change 

		     signal (sig_nr, my_signal_handler);

	    to 

		     signal (sig_nr, my_signal_handler);
		     { struct sigaction sa;
		       sigaction (sig_nr, (struct sigaction *)0, &sa);
		   #ifdef SA_RESTART
		       sa.sa_flags |= SA_RESTART;
		   #endif
		   #ifdef SA_INTERRUPT
		       sa.sa_flags &= ~ SA_INTERRUPT;
		   #endif
		       sigaction (sig_nr, &sa, (struct sigaction *)0);
		     }

	    Note that while this applies to most system calls, you must still
	    check for EINTR yourself on read(), write(), ioctl(), select(),
	    pause() and connect(). See below. 

	    (2) Check for EINTR explicitly, yourself: 

	    Here are two examples for read() and ioctl(), 

	    Original piece of code using read() 

		   int result;
		   while (len > 0) { 
		     result = read(fd,buffer,len);
		     if (result < 0) break;
		     buffer += result; len -= result;
		   }

	    becomes 

		   int result;
		   while (len > 0) { 
		     result = read(fd,buffer,len);
		     if (result < 0) { if (errno != EINTR) break; }
		     else { buffer += result; len -= result; }
		   }

	    and a piece of code using ioctl() 

		   int result;
		   result = ioctl(fd,cmd,addr);

	    becomes 

		   int result;
		   do { result = ioctl(fd,cmd,addr); }
		   while ((result == -1) && (errno == EINTR));

	    Note that in some versions of BSD Unix the default behaviour is to
	    restart system calls. To get system calls interrupted you have to use
	    the SV_INTERRUPT or SA_INTERRUPT flag. 

*  We now have a READONLY bitfield.  We should pre-beta start using
   it consistently.  This mostly (so far as I can see) means:
   o  Setting it on constant strings.
   o  Setting it on constant bignums.
   o  Hacking obj_Neql() to compare immediate when the operands are
      not READONLY.

/************************************************************************/
/*-    SHOULD BE DONE PRE-BETA, BUT WE COULD DELAY THIS UNTIL AFTER A FINAL ALPHA	*/
/************************************************************************/


   [ CAN WE IDENTIFY JUST NEEDED HOOKS FOR THESE, AND
     DEFER REST OF IMPLEMENTATION TO POST-BETA? ]

*  (!) Implement code to guarantee that we generate new IDs for all users at
       installation time.
       Note rootIssueNewLongnamesToAllNatives is already written.

*  Should we go ahead and have proxies for built-in classes include
   the hardwired class identification number?  So that the interpreter can know
   instantly whether a given proxy is a string, say?  Or is it sufficient
   to do a simple softcode hack in ]request?  Or should proxies
   include a hashcoded class ID that works equally well for hardcoded or
   softcoded classes?

*  Any needed hooks for switchable conversation logs in rooms.

*  Any needed hooks for message lists in rooms separate from the conversation logs.
   Or is supporting both in one room too mickeymouse?  I think perhaps it is.
   Yet it is easy to imagine wanting to say hello to someone without it being
   posted as a log.  Is 'whisper' sufficient unto the task?  Hrm.  I also find
   that reading Citadel style shouldn't require actually going to the room:
   'n(ext)' should print the next message and 'r(eply)' should post a reply.
   Does this make 'r(eply)' inherently different than 'say', though?  Or just
   another way of doing a remote say?
     Maybe entering a room should print
      "15 unread logged messages, do 'n(ext)' to read first"?

*  Any needed hooks to keep track in each avatar (user might be better? -- a
   multi-avatar user won't want to read the same messages twice) of the last
   message read in each room to which the user is subscribed:  Together with
   room logs, this is most of the infrastructure needed to implement Citadel
   style multi-room message reading.

*  Any needed hooks for implementing a flexible "hints" system.  I'm thinking
   of a property object on which a count is maintained for each potential hint.
   When, say, a connect-notify message is issued, the count is incremented, and
   if it is a power of two, the hint showing how to suppress connect-notify
   messages is issued.  This would give lots of hints early on and rapidly fewer
   thereafter.

*  Additional .folksBy. entry for backstay.Backisle vs backstay?  This might
   pose a problem when folks move?  Or just update it along with the other
   info?

/************************************************************************/
/*-    NOT YET TRIAGED	-- HARDCODE					*/
/************************************************************************/

*  An oop-natural way to deal with server permissions is to use objects
   as capabilities:  If you own a Camera instance, then you are allowed
   to do 3D drawing via it, say.  We're obviously doing some of this
   already!
     Making this work has some obvious implications (and probably
   some inobvious ones I'm missing):

     (1) If objects are capabilities, people cannot create them
         freely.  I suspect the best solution is a createRule
         slot in classes which replaces the current (?) 'fertile'
         bit.  Presumably a 't' value allows free creation, and
         a 'nil' value forbids all creation, while a function
         value gets called to determine creation rights...?
           LATER: The safest design for the latter appears to me
         to turn the createRule into a root-owned fn which does
         the actual object creation inside an asMeDo{...} scope.
           LATER: Do we have to make it a 'root' thing?  How about
         if instances of createRule-controlled classes can only be
         created by the owner of the class?  This will typically be
         root, but now the mechanism is usable by plain users who
         want to issue capabilities.

     (2) We cannot allow this mechanism to be defeated via free
         subclassing and substitution of the creationRule.  Either
         we don't allow subclassing of classes with non-trivial
         createRule values, or we do not extend parent capabilities
         to them, I suppose?  The simplest and most natural rule,
         I think, is just to not extend capability privileges to
         subclasses.

     (3) We cannot allow this mechanism to be defeated via free
         import of objects from untrusted remote Muq servers.
         We have not yet defined how remote object handling works,
         so this is a monkeywrench thrown into vaporware:
         *  We want remotely written avatar drawing code to run.
            So remote code must be written with the concept of a
            Camera matching our local concept of Camera.
            Thus, we must have some notion of a remote class
            being equivalent to a local class?  Or at least of
            code written for a remote class being able to run
            with a local class.
         *  We cannot allow remotely created capability objects
            to be freely imported if capabilities are to be
            meaningful restrictions.  (Importation might be
            allowed given public-key signatures?)
         *  Remote objects will only be interpretable when
            referred to some class.  The two obvious possibilities
            are that we import the remote class, or that we refer
            to a local class with the same hashcode signature.
         *  One  enforcement possibility is simply to disallow
            import of objects referencing classes with non-t
            createRule slot values.
         LATER: Minimum restriction is probably best.  If we have
         a lisp-style 'EQ' comparison and count an object as a
         capability only if 'obj.class EQ privilegedClass' does
         that do it?  Then we just do a simple check on object
         import to verify that obj.class is not both local and
         privileged?  Right now we never import objects anyhow,
         and will eventually do so only for proxy-caching purposes.
         Perhaps we need to systematically distinguish proxy-cache
         objects from native ones?  Or we can use a PROXY object
         to represent the class link even if otherwise unneeded in
         the problem cases, since that keeps object.class from being
         EQ to any local class?

     (4) We cannot allow free reclassing of objects to classes
         which have nontrivial createRules.  We do not yet support
         object reclassing, so this is another monkeywrench sailing
         into vaporware.
           LATER: Again, a simple check on class.createRule before
         doing the reclass seems sufficient.

     (5) The capability-providing code must have a bulletproof way
         of determining that a presented capability is valid: A
         class-determining primitive which cannot be maliciously
         bypassed via new methods, say.  We also need to be able to
         ensure that internal functions supposedly protected by the
         capability check cannot be reached via bypass routes.  Are
         our pointer-forging defenses firm enough for this?
          LATER: a primitive EQ check should be good enough, as long
         as the class field fetch logic cannot be bollixed.  Perhaps
         a primitive for fetching the class field is called for, if
         we allow 'get?' and such to be redefined as generics?

*  May need a FINALIZED flag:  We will often need to run some
   code at the point where an object would otherwise have gotten
   garbage collected, which means it has to be left allocated
   long enough for the code to run.  After that it will get
   garbage-collected again.  If we have a FINALIZED flag, we
   can maybe make sure finalization is done exactly once.
     Might work something like:  When an object is ready to
   be gc'd we put it in a queue ready for finalization; When
   the finalization method runs, it sets the FINALIZED flag;
   when we gc a MOS object with teh FINALIZED flag set, we
   can truly reclaim it.
     Probably need a reasonably quick way of discovering that
   a MOS object class -HAS- a finalize method before going to
   all this work?  If we use two bits, all of this gets easier;
   one for ready to finalize, one for finalization completed.
   If we use a 'free' operation which clears the ALLOC flag and
   increments the unique bits, we don't need the second bit,
   but hanging pointers on the stack or wherever have to be
   dealt with.

*  May need a FRAME_HOOK type flag meaning that the object has
   properties dependent on animation time:  When animation time
   changes, the animation function should be called before using
   the object.  This seems to imply we need a FRAME_HOOK_RUN bit
   also, recording whether the animation function has been run
   since animation time has last changed?  This implies a single
   animation time per user, which I think is a realistic restriction.
   We'll need to clear the FRAME_HOOK_RUN bitmap each time the
   animation time is changed. We will of course also need a dil
   mapping objects to their animation functions.
    LATER: What implications are there for this when running avatar
   rendering code as a guest on a remote machine?  When running
   several guest avatars on the same machine?  We don't want to have
   to check the FRAME_HOOK flag via the net, and we do want to keep
   all the avatars in a given display synched to the same time.
    Maybe each dbf object should have a pointer to an object
   containing the current animation time, which can thus be shared
   and automatically synched?  And each guest avatar should no
   doubt have a local dbfile while it is running, yes? 
    LATER: Below GL analysis suggests the shared object be a camera...?
   Or does this create too much trouble if we have multiple cameras
   viewing a scene?  Seems like the multiple cameras might be viewing
   multiple times.  And that updating the time on all cameras in the
   scene isn't incredibly onorous?  The alternative is that all
   cameras viewing a given time point to a common object recording
   that time.  Is that too fine-grain an object?  Probably not.  So
   a SceneTime object, then?  Handy for hooking up to widgets.
 

*  3D graphics API (package GL):  I'm not overly happy with the way ThingLists
   came out, and for Muq I think there needs to be more of an emphasis
   on making simple things simple, to entice beginners.  Sooooo...
   *  I still like the idea of having the Camera be the center of
      the 3D graphics universe, but I think we need direct drawing
      commands off it:
	  myCamera.drawPoint()
	  myCamera.drawLine()
	  myCamera.drawTriangle()
	  myCamera.drawRectangle()
      And of course
	  myCamera.clear()
      This in turn seems to imply that everything else needed for
      drawing needs to have natural per-camera defaults:
          myCamera.defaultLights
          myCamera.defaultMaterial
          myCamera.defaultTranform1  ("Modelling"?)
          myCamera.defaultTranform2  ("Viewing"?)
          myCamera.defaultTime
      For stored graphics, we probably want classes
          Points
          Lines
          Triangles
          Rectangles
      which contain Point and Facet Tables:  I thought that worked
      out well in Skandha4.  We can then have a command
	  myCamera.draw()
      which accepts such things.  The Points Lines Triangles and
      Rectangles classes probably need their own
          myTriangles.defaultMaterial
          myTriangles.defaultTranform
          myTriangles.defaultTexture
      slots, which this time default to NIL:  This allows the
      users to supply default positions and colors for them in
      a natural way without being forced to do so.  We want the
      camera to move naturally through the scene, so drawn thing's
      tranforms should -not- be multiplicative with camera position?
        LATER: We want to do things like turtle graphics naturally:
      Draw, move a bit, draw, move a bit &tc.  This means what we
      really need is a cursorTransform associated with the camera,
      which is independent of the camera's own modelling and viewing
      transforms.
        LATER: For tutorial purposes, we likely also want to be
      able to have more sophisticated immediate draw commands like
      drawBox, drawBall ... perhaps up to and including drawFace
      and drawFlower?  Do we need make these all look
      like myCamera.drawFlower()?  If so, we need to be storing
      these as propdir entries rather than slots, obviously(?)!
 

*  Phase out next_unique_to_issue in favor of just incrementing the
   stored unique value.  Make sure we don't nuke unique during
   initialization!

*  I now think that the way to handle large objects is to just
   mmap() the db file, and then let the host virtual memory
   hardware page it in and out.

*  I would like to do vm_Realloc() pre-beta:

   o  A RELOC bitmap has been defined in vm.t
      Intended interpretation is that when RELOC is set,
      the slot contains the address of the object instead of
      the object itself.

   o  vm_Free() needs to be hacked to clear the ALLOC bit on the
      indirect reference as well as the direct one if MARK is set.

   o  dbfileGet() (or its caller locB()) need to be hacked to respect
      the RELOC bit when loading into ram.

   o  sizeGet() (or its caller vm_Len()) needs to be hacked to
      respect the RELOC bit.

   o  sizeSet() may need a corresponding hack before we are done,
      although at present it is only called at vm_Malloc() time.

   o  vm_Realloc() itself needs to be re/written.  (There's an implemention
      in place, but it never gets called, so it can be ignored.)

   If that gets done, we should change Stack to use vm_Realloc() when
   resizing its vector.  Possibly we should mutate Stack into Array
   at the same time:  CommonLisp arrays support fillpointers and stack
   operations anyhow.  Or maybe Stack, Queue and Deque should converge?
   Or maybe keeping them all formally separate is justified by code
   clarity, but the implementations can be merged into a single file
   that shares lots of code?
 
*  Once we do vm_Realloc(), we can implement push,pull,shift and
   unshift on raw vectors, and the current plain Stack and Queue
   objects cease to have much utility.  I think perhaps we should
   change the latter into BoundedStack and BoundedQueue at that
   point, with numeric limits on size and perhaps a 'leaky' bit
   -- when 'leaky' is 't', they could discard the oldest datum
   on overflow, rather than throwing an error.  (Or maybe we should
   have separate LeakyStack and LeakyQueue classes, to make things
   more transparent?)

*  Be nice to virtualize the object 'objname' slot:

   We moved networking overhead info into separate btrees because
   that is Fairer, because then objects without external references
   don't need the overhead.

   Similarly we moved the propdirs into separate btrees?

   MAYBE WE SHOULD ALSO move object 'name' fields to separate btrees?
   Most objects probably won't have the field set, and access speed
   should generally be noncritical?  That would cut vanilla object size
   effectively in half, since they would then sit in dual instead of
   quad slots on disk?

*  I'm not sure the 'owner' field on jobs actually makes sense.
   May want to look at removing it.  On the other hand, the
   cost of leaving it in is minimal...

*  Might look at reducing the overhead on bignum objects.

*  Be nice to hack obj_Neql() compare immediate types via
   simple 64-bit compare.  Floats are an exception, want
   1.0 == 1 so we can't just compare bitpatterns for that.
   If we don't do this pre-beta we probably cannot do it
   at all, as a practical matter.

*  Should we make NIL sort before everything else?  This might
   make objects compare by value better, say.  If we made the
   octave field most significant, and allocated a special
   zero octave just for NIL, that might do it...?   Might also
   unleash a ratsnest of special cases?  Hrm.  Although since
   it only affects disk I/O maybe not that many?

*  The canonical representation for a class should maybe be
   the class name followed by the field names followed
   in order by the canonical representations of the immediate
   superclasses, all hashed down to a fixnum.  This would provide
   a cross-server definition of when two classes are identical --
   that is, of when two objects belong to the same class.
     We might wind up wanting .classesBy.number[] and
   .classesBy.name[] indices...?  Similar to the folkBy indices?
   Although these might be unneeded for local classes and begging
   for spam if opened to foriegn classes.  Hrm.

*  It would be nice to track total uptime and current
   continuous uptime for each server.  If we also had
   the creation date of the db recorded, it would then
   be trivial to compute percentage uptime.
     A little display of which servers currently have
   the best uptime stats would also be cool. :)

*  Should we provide mos keys with PREV as well as NEXT pointers?  The
   issue on my mind is that right now old keys get recycled as soon
   as there are no objects referencing them.  But if we switch to
   doing gc by dbfile, it will often be the case that system libraries
   have no objects referencing the old key, but that other dbfiles are
   full of them.  Double-linking the list and keeping keys indefinitely
   may be a better idea?  The PREV pointers could be explicitly nulled
   out by hand in exceptional cases, of course.

/************************************************************************/
/*-    NOT YET TRIAGED	-- SOFTCODE					*/
/************************************************************************/

*  We should rename muq/pkg to muq/src or muq/softcode or muq/sft or
   some such -- 'package' is being overloaded.  Perhaps at the same
   time we should add subdirectories to it:  Things are going to
   rapidly get overcrowded.  How about
      muq/src/000-muf/
      muq/src/010-gl/
      muq/src/020-micronesia/
      ...
   to relieve the crowding?

*  Possibly we should have the compilers normalize this_and_that
   to thisAndThat?  This would go a little ways towards keeping
   both religions happy.

*  There seems to be a problem where any dbfile D can wind up owning
   keywords, and if D isn't mounted yet during bootup, we crash.
   What's the solution?

*  Be nice to implement a DNS helper before beta, just to eliminate
   one huge source of nasty lags.

*  Should really look at all the classic Lisp sequence (and
   collection?) operators and see which ones should be implemented
   on Set and Index objects.  I'm primarily thinking of mapcar and
   kin, but there may be other idea nuggets in that pile?

*  Muq arithmetic operators should apply to numeric vectors per J
   conventions, I think -- it seems to have the best thought out and
   tested array operators.
     Index objects should in turn be semantically consistent with
   vectors:  We're taking the view that vectors are abstractly just
   Index objects with odd restrictions on the allowable keys.  So
   that pretty much dictates the operation of numeric operators on
   Index objects.
     And Set objects in turn should be semantically consistent with
   Index objects: We're taking the view that Sets are just Index
   objects with the value fields restricted to being 't'.
     All of which implies that we have to look elsewhere than the
   arithmetic operators for names for set union, intersection and
   difference operations on Index objects:  The above-mentioned
   CommonLisp collection (?) and sequence operators seem a good
   hunting ground.
    ------
   It would just be really, really cool, and very little effort, to
   hack up + - &tc so they could be used to do union/difference/etc
   on Indices.  This really just requires having them default to
   running a generic function when the types are unsupported in
   hardcode, and then defining appropriate methods to those
   generics.  For the first cut, at least, the methods can be
   entirely in softcode with no particular effort at efficiency.
   Should we include a 'map' function, so we can take the image
   of one set A mapped through another set B and return it...?  Be
   nice if we could use the syntax b[a] for this, but that would
   overload it badly, near as I can see, since `a' is already a
   valid index value. :-/
     There is a bit of an issue here as to naming of the prim vs
   the generic.  I think maybe we need a separate 'mufGeneric' package which
   contains the generics?  Each prim can then invoke the appropriate
   generic in it if found...?  That way invoking 'muf:* by name still
   works (for example), the only funniness should be 'muf:*
   unexpectedly calling itself 'mufGeneric:* in diagnostics, which is
   not too bad.  (We could even special-case -that- if it became a
   serious issue.)
     LATER: Actually, using + - &tc for Sets sucks because it conflicts
   with J-style pointwise operations on vectors and indices.  The
   basic idea remains sound.  But the mufGeneric:* idea is more lame
   than we want: Should be possible to have all bytecodes transparently
   be valid generic function objects in muf:, and have the assembler
   internally use a table of generics with bytecode equivalents when
   compiling calls.  This makes the bytecodes almost entirely
   transparent at both compiletime and runtime.

*  Can we get MUF compiling simple recursion properly?  Not being
   able to write factorial recursively in straightforward fashion
   is pretty lame.

*  Should we try fixing the infamous tests 28 and 29 before beta?
   (== True lambdas.  After years of dithering, I've pretty much
   concluded that distributed operation comes first, and that
   making compiledFunctions read-only  -- so that they can safely
   and trivially be cached and executed remotely -- comes first,
   and hence that closures should be done by putting the variables
   in uninterned symbols and including (only) pointers to the symbols
   in the compiledFunction objects.  Normal proxying then takes care
   of doing the updates appropriately even when the function is
   executing remotely -- providing permissions stuff allows it.)

*  Possibly user state muqnet protocol should include a "sunset"
   field, after which the current public key should no longer be
   considered valid?  Perhaps with a hack so that it can be
   decreased but never increased, as insurance against loss of
   private key?  Presumably we should also register
   a "next" public key, so that we can have a smooth switch-over from
   one key to the next, again with a no-overwrite hack as insurance
   against private key loss.  And finally perhaps a suicide flag for
   invalidating an identity completely?  That way if a private key
   is lost, the owner can kill off the compromised character entirely.

*  Should we establish @.avatar (or @.room ?) variables?  I'm
   merely thinking of making life a bit easier for folks
   who drop into @muf from mshshell:  Right now they have
   to use @.task.taskstate to access the avatar, which is
   a bit verbose and unintuitive.  @.avatar might make
   various newbie customizations more fun to do (and to
   document!)

*  As a design principle, all Muq collections should if at all
   possible be available via the property mechanism.  The various
   muqnet published things, the set of active handlers in a job,
   and the /proc info are examples of stuff not currenty available
   in this way.

*  The various dynamic bindings on the job stack should all (?)
   be augmented with static per-job btrees -- slower, but able
   to support much larger sets of bindings.

*  "rule" is a shorter synonym for "policy".
   LATER: "may" prefix is shorter than "rule". :)

*  Might want to handle job forks by setting READONLY on the
   propdirs?  If the two jobs never modify the propdir again, they can
   share it in peace.  (Probably the most common case, so handling it efficiently
   is nice.)  If only one modifies it, it must first copy the existing
   propdir by value;  This case is basically optimal.  If both modify
   it, they both wind up having to copy the full tree, which is
   suboptimal, but probably not too common.
    Same logic might be used generally when duplicating objects?

*  Um, seems like package nicknames don't make it from ~root.lib into
   .lib?  Be nice to do something about that.  Maybe ~root.lib should
   simple be the same object as .lib?

*  It would be nice to have a dbfileLint command which locates
   interdbfile links likely to be broken by updates, in particular
   links to things in dbfile other than public symbols, packages,
   and the dbfile instance proper.

*  To have any hope at all of porting dbfiles between servers, we
   probably need to translate all keyword references to portable
   form when dismounting a dbfile, and reverse the process when
   mounting a file.  Sort of link editing.
     LATER:  Actually, there's no reason this couldn't be expanded
   to deal with all links to external symbols which are public to
   some other package.
     LATER:  Possibly the 21-bit dbfile field should be interpreted
   as being a per-user namespace?  With some sort of translation
   table maintained between the user's abstract space and the
   current server's space?  This might allow for sane migration of
   user dbfiles from one server to another despite inevitable
   conflicts.

*  There are various values class Muq isn't preserving yet which
   it should, such as bytes between garbage collects.

*  Should we implement generic funcions specialized on individual
   objects via a btree?  What if different people want to contribute
   such specializations?  Should they be allowed to do so, or does
   this open the door to subverting the intention of the generic?
   If we do allow it, don't we have to store the methods on the
   objects, or in a btree associated with the owner of the object?

*  Should it be possible to define a class which uses the
   array interface but is implemented differently?  I'm
   thinking of procedurally defined textures which look
   like normal arrays, say.  This might make for more plug-and-play
   softcode in some situations.  On the downside, it might complicate
   life for C-coded primitives which are expected to work on these
   arrays just like they work on vanilla arrays...?  Could one provide
   some sort of automatic copying into a vanilla buffer array in such
   situations?
     Sparse arrays are a somewhat similar problem.

*  Be nice to put in at least the hooks for a nice package
   management system modelled closely on dpkg.  I'm thinking
   of such things as dbf fields for

     requires
     suggests
     conflicts
     preinstall
     postinstall
     preremove
     postremove
     configure    (GUI script to manage installed package)
     installstate (broken, complete &tc)

   and also identity fields such as

     dbcreator
     majorversion
     minorversion

   What should the format be for 'requires' etc?  These need
   to be able to identify the dbfile in a way sufficient to
   locate it on a mirror site, and to say stuff like "need
   at least major version 3, minor version 12".  Maybe a
   string with the author's shortname followed by package
   name followed by version? 1834235315135135:Lisp:3.55?
     LATER: Including author's textname might be good even
   if it is ignored except for display purposes...?  Or
   should we be looking that up based on shortname?

   Should we have a prim or two for comparing version strings?
   Or should versions be objects or binary somethings?  Lack of
   efficiency requirements would seem to favor a transparent text
   format? Maybe a string of KEY=val pairs ala Unix environment?
   But a special string subclass would allow standard < op to be
   used to compare versions, no?  But then creating version strings
   becomes less intuitive?  Unless storing a string into the dbfile
   slot for version converts to appropriate subclass automatically?
   Why not just use dbfile object as the basis of comparison?  That
   would mean the 'requires' list would have to consist of dbfile
   objects? That would be opaque to casual inspection.
     LATER: Just requiring that versions be floats seems more
   to the point.


   What should the protocol be for locating dbfiles?

   How should we handle mirroring?

   How should we distinguish development/frozen/production versions?
   Is embedding such information in dbfiles a good idea?  Or will it
   tend to propagate stale information unduly?

   Should the dbfile mount command take a list of package number
   remappings to perform on the mounted db?  If so, should that
   mapping be preserved somewhere?  Should the distribution mapping
   be recorded somewhere?


*  Even if we don't use it initially, it would probably
   be a good idea to include a timestamp in each network packet,
   to support future developments such as protection against
   replay attacks?

*  Given a central design thrust on transparent networking, we
   probably need to be able to cache local copies of any proxied
   object:  I have in mind in particular large arrays used for
   texture maps or voxel data or such -- fetching these over
   the network once per framedraw is obviously out of the question.
     One approach might be to add to the standard header a "last
   update attempt" datefield, which is NIL for local objects.  I envision
   then, on each access to an object, checking to see if this field
   is non-NIL, and if it is, checking the current date and the
   5-bit update latency field and if the copy is stale enough,
   firing off an update task and updating the "last update attempt"
   field.  But NOT blocking the current thread until the update
   completes.
     An "update in progress" bitflag might be useful to prevent
   creation of an unbounded number of update tasks if the update
   time becomes greater than the update latency, but if the flag
   got jammed ON, it would prevent updates forever :(.  Better
   might be a way of searching the task db for a task already
   doing the update.
     Should we invoke the Fairness Principle to exclude burdening
   the local objects with the lastUpdateAttempt field?  I think
   perhaps we should envision a typical Muq server as having as
   many --or more-- proxied as local objects, and hence the proxy
   case as the normative one.  This leaves saving one field on
   local objects as a minor optimization which can be left for
   later, if ever needed at all.
     The above leaves unanswered the question of when/how we
   decide to construct a local proxy of a remote object. The
   only obvious simple answer is: The first time we try to do
   something with a proxy other than pass it around.
     The vision of constructing local caches of (say) large
   voxel arrays also adds some urgency to the question of avoiding
   multiple local copies.  Do we need an index of all cached objects?
   If so, how do we keep the index from preventing garbage collection?
   Soft pointers raise their head again.  Do we need a soft-pointer
   bit in the pointer format?  Do the existing hanging-pointer bits
   do the equivalent already? No, because the soft-pointer bit has
   quite special semantics: It must not be traversed by gc() and it
   must be ignored in soft mmu lookups, but gc() should set it to
   NIL if invalid, as with any other hanging pointer.

*  The above raises the question of whether we need objects with
   "never-cache" bits, for when such lazy updating is simply
   unacceptable.  Since private data is presumably never exported,
   hence can never be cached, is it sufficient to simply make
   uncachable data private?

*  Why does micronesia need an elaborate mechanism of its own to
   publish properties and lists?  Why can't this be a fairly simple
   variation on making normal objects and vectors transparently
   available via the network?
   ---
   Would it not be a huge win if Micronesia published lists could have an
   interface more like standard Muq objects?  Publish a value just by
   val -> obj/key?  Can we somehow doing this by defining a new native
   class, or...?

*  After reading Design Patterns, I think I need to go through oldmud and
   see what of it I can apply.  In particular:

   *  Maybe many mixins should work by delegating the implementation to
      a subobject variable at runtime.

   *  Closely connected to above, I want to check that the basic events
      of interest to a mud-level object are handled by readily customizable
      code.   It should be trivial to change the way an object handles:
      * Being looked at.
      * A 'get' of a movable object.
      * A 'press' of a button object.
      * A 'say/pose/whisper/page' to it.
      * A 'go' to it. (Traverse of an exit maybe should be separate at
        the code level, if not at the command level.)
      One definitely should not have to create a new class, then a new
      method, then an instance of the class:  It should be possible to
      update the behavior of vanilla existing objects in one step.
        Avatar response to 'look' should be a particular example of
      customization, albeit done at the subclass definition level instead
      of at the object variable level -- presumably it simply changes the
      default value of those policy variables in new objects.

   *  I am particularly struck by Design Pattern's point that mentioning
      a concrete class in creational code is the moral equivalent of using
      a non-manifest constant in conventional C code:  It hardwires the
      particular classes which will be used in terrible fashion, making the
      code very hard to re-use/adapt/live-with.  I'd like to look very
      carefully everywhere in the oldmud logic where objects are created,
      and see if at least Factory Method cannot be applied.  Or maybe a
      per-user Builder or Abstract Factory which specifies the results of
      the UI @dig &tc commands?  Then someone can create MyExit class and
      have the UI use it instead of the vanilla ones.
        In the Muq context, as far as I can see, it would suffice just to
      have an object which maps names like "exit"/"room"/"avatar" to matching
      class objects of which we can then make instances.  Easier to update.


*  Should we set up an @set command?  I'm thinking of
     @set looknotify=<on/off>
     @set connectnotify=<on/off>
   and random flags like that.  If we do this, we should probably
   set up a factored implementation which makes it easy to add new
   flags just by updating a data structure, but I'm not sure offhand
   what the best way to do that is.  Sort of a miniature version of
   the current factored shell commands setup?  If so, can we avoid
   duplication?  Should we just use the existing command support:
     @setlooknotify <on/off>
     @setconnectnotify <on/off>
   or maybe just
     @looknotify <on/off>
     @connectnotify <on/off>
   etc?  That would avoid any duplication of mechanism.

*  Should echoCompleteString take a continuation, so that we can have
   some subtask wait for completion and then pick up?  Right now, for
   example, we cannot append anything to the string, and we can't
   guarantee that objects in the room print out after the room
   description is complete.

*  Be nice to have per-user nickname dictionaries, to allow personal
   renaming of friends (and perhaps enemies).

*  A room-capacity field might allow both privacy (a table for two) and
   spam protection.

*  for i from 0 upto 1000000 do{ "a" i toString + -> a  i --> x[a] }
   Why does that result in a 66Meg database, instead of a 6Meg or so
   database?  Do we have a really gross efficiency issue somewhere?
   Doing
     for i from 0 upto 1000000 do{ i --> x[i] }
   appears to yield roughly the same result, so the problem would
   appear to be in the btrees rather than strings.  (Unless we're
   storing bignums instead of fixnums...?!)
   Doing
     for i from 0 upto 1000000 do{ [ "%x" i | ]print -> y y --> x[y] }
   appears to yield roughly the same result so bignums should be off
   the hook...?
    [Actually, a million hashtable entries at 8 bytes each for key,
     value, hash, is 24 million bytes right there, so 66Meg isn't that
     far out of line.  Assume leafs wind up half full and one is up to
     48Meg.]
   But doing 
     for i from 0 upto 1000000 do{ [ "%x" i | ]print -> y y --> x[y] }
   in root seems to run for at least 12 hours...?!


/************************************************************************/
/*-    CAN BE DEFERRED TO POST-BETA -- HARDCODE				*/
/************************************************************************/
   
*  Should we require  a "make: x.y" before "v --> x.y" by way of catching
   typos...?  Perl seems to have evolved a 'strict' mode for large software
   projects which provides this sort of checking.  Hrm.

*  asMeDo and asUserDo should likely set the current package (and thus
   database file) to that of the specified user, to avoid allocating objects
   owned by the user but scattered all over the database files due to sloppy
   softcoding.

*  We will eventually want softcode hooks to roll back a given db file to
   a given version, to avoid having to take down the entire server in order
   to do this.  But that can wait for post-beta.  Ditto providing a softcode
   API for inventorying the set of old versions of a dbfile, or reading
   selectively from an old one.

*  Errors during opening a db file need to switch from being fatal
   (crashing the server) to being warnings (throwing an exception).

*  We need a strategy for handling hanging pointers.  I think the
   best is to catch them as they are being loaded onto the stack.
   This allows stack-to-stack and off-stack operations to run full
   speed without checking, it localizes the fixes needed to a
   relatively small number of instructions, and it allows us to
   fix the location from which the value is being loaded.  Constant
   loads from functions are a special case:  My current notion is
   to check the constants at the start of each call, so that constant
   loads afterwards can run fullspeed.  A bit aggravating to have to
   do this on every call indefinitely, but I see no better idea.

*  Should we try setting up universal C macros for reading
   and writing heap fields?
   -> The 'set' macro could provide a central point at which
      the gc logic can check for creation of intergeneration
      pointers.
   -> The 'get' macro could provide a central point at which
      to trap hanging pointers.

*  Aren't we always using 9 bytes to serialize a fixnum?  Be nice to
   have more efficient representations for common short cases.

*  Should the distribution binary be statically linked to avoid
   library skew problems?  Or an optional static link version
   provided?  Should see how much larger a static link version is.

*  Should we reserve slots in the db file header for the
   IP (128 bits?), PORT and PID of the server which has the
   file open, if any?   I'm thinking about, say, 128 Muq
   processes on a 16-CPU machine supporting 100,000 users,
   where any user can log in on any process, and the process
   just requests that the relevant user .db file gets handed
   off to it.  If the above information is written into the
   header, implementing that should be pretty straightforward.
   Even on a 1024-CPU non-shared-memory cluster running off
   NFS, the above should be sufficient to make things work...?
    This idea -does- make the current pid file convention inadequate,
   of course...
    It also suggests that user files should use proxies when 
   referring to each other.  Should we try to enforce that at
   runtime?  We can convert the db file to this form pretty
   quickly at dismount time.  What about other users who have
   hard pointers to a dismounted user?  Seems like we should be
   able to trap the pointers one at a time as they fail, and
   convert them to appropriate proxies, if we just have a central
   db of which files are on which server at any given time?

*  It would be nice to do server upgrades without kicking
   users off.  Also without interrupting continuous uptime.
   Would it be hard to just write the socket-related info
   to a file and then exec() the new server, rather than
   having to actually take it down?

*  It would be nice to get CONS cells down to zero overhead both
   on disk and in ram.	This seems possible if we allocate special
   segments for them, so that the type information is implicit, and
   if we access them via memory-mapping instead of by loading them
   into bigbuf.  (Overhead is currently down to < 4 bytes vs 16 bytes
   of 'car' and 'cdr' so this isn't as urgent as when we had 40
   bytes of extra overhead.)

*  Be nice to in due course implement a Bag btree variant, interpreted
   as a Set in which each object has a count -- so adding an object to
   a Bag in which it is already present would increment the count,
   instead of being a no-op.  I presume the count would be exported as
   the Index-style value of the key, unless that turns out to be badly
   inconsistent with some pre-existing convention.

*  It might be nice to have a rootPackDbfile command which basically
   defrags a dbfile, moving all possible objects as zeroward as
   possible subject to the restriction of breaking no links into the
   dbfile from other parts of the db.  (Or should it change those
   links also...? Depends whether it is supposed to be effective only
   locally, or to be portable between servers.  Maybe different
   policies for local vs library dbfiles?)

*  Might be plausible to have whodunit tracking be switchable on
   a per-dbfile basis:  Optionally keep a separate b-tree tracking
   datum creation date, last modified date, and the responsible party
   in each instance.  That would cost a lot of time and space when
   switched on, but there might well be applications where the
   information was considered essential and the time/space cost
   considered negligible?

*  Should we cut back btree nodes to 256 bytes, so as to waste
   less space on small, nearly empty Set and Index objects?
   LATER: Actually, I think it makes more sense to hack up a
   special leaf type half the size of a regular leaf, for trees
   consisting of a single leaf.  Which means this can be deferred
   to post-beta pretty safely.

*  Should we make the til objects implement the regular Index
   protocol, accepting and returning 3-vectors as values?
   Not terribly efficient, but it fits the functionality needed
   in the API available, and we're not expecting to use the API
   heavily anyhow.

*  obj_Do_Backup() should be able to compress the new CURRENT
   files asynchronously (except when called on server exit)
   and shouldn't have to do any decompression at all.  At present,
   enabling asychronous compression introduces a race condition
   that crashes us on a missing ROOTDB-RUNNING.db file :(.

*  For doing two-generation garbage collection, it would be good
   if bigbuf had a bit per object meaning "this object is newly
   created".  Then we could do full gc on a dbfile only after X
   number of bytes of newly created objects have been written to
   disk.  This would avoid blindly running the full gc when in
   fact the generation-0 gc is catching all the garbage.  I
   believe this can be done post-beta.  Not sure how this idea
   relates to the idea:
    Allocating a bigbuf bit for "this object may have references
    to it on disk" would allow fast in-ram generation-0 garbage
    collection passes.  This has little architectural impact,
    hence could be done post-beta.
   Hrm.  Guess they -are- separate, since a freshly created object
   may be known to be referenced by an object just written to disk.
   LATER: I've added an OLD_GEN bitmap in support of this stuff.
   Not used for anything as yet.  May need to add another bit
   meaning "may contain pointers to NEW generation".

*  There's some icky failure mode where we hang in the muqnet2 64-job
   test. :(   Maybe try 128-job or 256-job runs and see if they fail
   more consistently?  I've changed various |writeStreamPacket
   calls to |maybeWriteStreamPacket calls, which might have resolved
   this.

*  Should we hack classes to store class values in symbols off the class
   object rather than in the class itself?  This would make the class more
   read-only and hence sharable in a distributed context?  Might not be
   much harder to special-case remote class objects, however...?

*  Should the db use identical endian conventions on all machines?
   This would simplify mirroring, porting &tc in a shared environment,
   and the disk throughput penalty should be minimal given CPU/disk
   speed ratios these days.
   LATER: No, because this prevents memory-mapping the .db file. But
   it should automatically detect and correct mismatched dbfiles.

*  Be nice to store encrypted passwords as unreadable bignum vals instead
   of as textstrings.

*  Should we add |toBase64 and |fromBase64 prims?
   And presumably toBase64 and  fromBase64 as well?
   (Damn, lost the PD code I was going to use for this in the disk crash.)

*  I think we forgot to create isAGuest and isAFolk assertions parallel
   to the added predicates.

*  We're going to need to support Perl-style 'eval' -- compile a string.
   This implies a message stream which is refilled from a string as necessary.
   An 'eval' can happen under arbitrary runtime conditions, so disturbing the
   current stdin message stream is an uncool idea.
   On the other hand, recursive 'eval's aren't an issue, because they happen
   at runtime, not compile time.  So:
   *  'inputString' and 'inputStringCursor' fields have been reserved on message
      streams: If they are non-NIL, stream should bes refilled as necessary from
      the string.  (Unimplemented.)
   *  A 'compileMessageStream' property has been reserved on jobs, defaults to NIL,
      cleared in child during forks, should used to cache a message stream, so we
      don't have to create and discard a mss for every 'eval'.
   *  Write an 'eval' to leverage these.  Since we support multiple languages,
      'eval' is probably a bad name: 'compileMufString' and 'evalMufString'
      might be good. Or muf:compileString and muf:evalString, so that other
      languages can use parallel forms like:
        lisp:compileString lisp:evalString
        perl:compileString perl:evalString
        apl:compileString  apl:evalString
      &tc?  But since MUF compilation is essentially an evaluation anyhow,
      perhaps the dual forms are not needed, and the "evalString" alone suffices?
   *  'inputSubstitute' field has been reserved on message streams.  The intent
      here is that we can implement something like a backquote-during-compilation
      feature along the lines of
        : xx { -> $ } `2 2 +` -> four  four ;
      where the subexpresion gets compiled, evaluated, and the the result
      then rescanned as part of the compilation.  The envisioned implementation
      is by setting mss%s/inputSubstitute to an alternate message stream (which
      will in turn have inputString and inputCursor set appropriately): input will
      then be returned from that alternate message stream until it runs dry, at
      which point the field will be nulled out and input will revert to the main
      message stream.

*  We've been using virtual slots a lot internally:  Would it be worth considering
   making available a virtual slot facility for the application programmer?  The
   win would be using the standard slot API without having to physically allocate
   an 8-byte slot on every object which logically possesses the virtual slot.
     The application hacker can already achieve the same space benefit by hand, but
   only at the cost of forgoing use of the standard slot API, reducing the oppotunity
   for transparent re-use.

*  Would it pay to introduce something akin to Unix 'environment'
   tables at the Muq job level?  I'm thinking of the fact that it is
   often very ugly to pass certain context data around explicitly as
   parameters, but very unclean to make them global variables.  Of
   course, we can freely stick properties on jobs anyhow.  Should we
   allow stack bindings of such environment settings, so they unwind
   cleanly?  Is that different from what special variables already do?
   (Or should -- not sure if they are implemented.) Hrm.

*  Might be worth having a switch to disable the small object cache,
   if only as a debugging tool.

*  Vanilla pointer swizzling doesn't seem very practical in Muq, as a
   tagged architecture.  But one might be able to convert the top 32 (say)
   bits of object references into a hard address into a table which
   has one entry for every existing object.  I don't see that being a
   mainstream win, but it might benefit some applications where ram
   use is not an issue but the time taken by lots of fine-grain
   dereferencing -is- an issue...?

*  I think it would be very handy to be able to do `muc "sin($x);"`
   in a shellscript, or just
      muf .lib ls
   from the Unix commandline or such.  All this really requires is
   that the server open up (say)
      $HOME/.muc-pipe
      $HOME/.muf-pipe
      $HOME/.mul-pipe
   named pipes and that small
      muq/bin/muc
      muq/bin/muf
      muq/bin/mul
   helper programs exist to handle the busywork of feeding the
   expression to the pipes and reading the result back.  No?
   Plus little in-db daemons reading the pipes.  Unix tradition
   would suggest that if (say) muq/bin/muc were invoked with
   no arguments that it issue a prompt and accept commands.

  


/************************************************************************/
/*-    CAN BE DEFERRED TO POST-BETA -- SOFTCODE				*/
/************************************************************************/
   
*  Should implement @make, and @put and @get?  (vanilla objects carriable
   by avatars)  @drop and @odrop fields...?

*  An @invite / @join pair would be nice, for facilitating social
   group assembly: @invite would send the current location, @join
   would jump to it.  Could also add an '@note here=<somename>'
   command, and then allow 'go <somename>' as a remote jump later
   (as well as using it for building tunnels between locations).

*  A look-notify would would be nice, facilitates getting acquainted.

*  A connect-notify would be nice, also facilitates getting acquainted.
   A new-user notify is probably much less important.

*  An @whois would be nice, to facilitate getting acquainted. Doesn't
   have to amount to more than a remote 'look'.

*  We should implement command groupings in 'help', so newbies see
   only the basic commands like say/pose/go.  There's a cmdHelpCategory
   generic function defined now to support this -- see 470-W-oldmsh.t

*  Need to remember to grep for "/sys%s/muqPort d," and kill all those
   debug statements :)

*  To reduce spoofing problems, how about having name normalization
   ensure that digits 0 and 1 are neither preceded nor followed by
   a letter?  That eliminates "ne11" and "11ewe11yn" and "0rigin"
   and such, while still allowing "robot_1" and such.

*  Improve support for 'why' property of tasks.  In particular,
   347-W-oldrequest.t:requestTimeoutFn supports it, but the other
   *TimeoutFn currently don't.  Should also attempt to have all
   ]request calls supply a :am property, and should write a
   user-level fn to display currently active tasks, including the
   'why' field.

*  (!) If task code doesn't already do so, should verify that replies are
       from who they are supposed to be from before accepting them.

*  Appears 'task'/']request' is firing off packet pairs currently, due to not
   setting the timeout right on the first continuation entered into
   the db...  See attached 98Sep06 muq.log for an example.

*  How about having xx-oldmud2 use a randomly selected password instead of
   a fixed one, to reduce the security risk of running the tests?  Doing this
   for nanomud also would reduce risk due to it being distributed...

*  Should switch to randomly generated
   passphrases.  intToManglish and manglishToInt are written but not used.

*  Can we have a robot bartender that says "Always a nice day somewhere, sir!"
   whenever someone says, "day"? :)

*  Mail?

*  We're going to need an effective way of preventing execution of
   the same muqnet request twice due to premature resends or lost acknowledges.
   I've been resisting this because it can add a lot of state to the server,
   but I'm now starting to see this is likely to happen more often, and be
   more objectionable, than I originally expected.
     I think the best solution is to have each dup-sensitive muqnet request
   handler keep a leaky circular queue of recently seen request numbers,
   along with associated hashnames, and do no new work for duplicates (but
   still issue an appropriate ACK, of course).

*  We should implement identity mirroring. I'm thinking of a
   facility allowing people to log into a backup server when their primary
   is down.  Hooks might consist of /muq%s/mirrorMaster and /muq%s/mirrorSlave
   values which point to the muq server which is mirrored/mirroring;  The slave
   server would query the master server periodically and update to match all
   native identities.  We could then have each Ruby machine mirror a Quartz
   machine, say.
     Alternatively, maybe we should just mirror complete dbs via ftp?  That
   would result in all building also being available, which is more satisfying.
   If that's planned, this might argue for keeping the original cluster on donna.
   Keeping the original cluster on donna would also keep the logfiles all coordinated,
   which is a good thing.
    LATER: Now that we have one user/dbfile, I think the sensible
   thing is to have a sister-muq's arrangement, and each time a user
   logs out, the db is updated at the sister sites.  There would be
   no master/mirror relationship in this model, users could log into
   any of the sister sites interchangably.  This suggests we need
   something like lastLogin + lastLogout values on User fields, to
   distinguish which db is the most uptodate...?  It is less clear
   what happens with animated possessions.  Do they run separately
   on each sister site, getting states out of phase with each other?
   Or...?
 
*  I'd like to be able to write anonymous functions in MUC as:
      { return $1+$2; }
   This doesn't have to be immediate, but let's keep the syntax
   available.  The above syntax, intended for very small anonymous
   fns passed as arguments &tc, has the advantages:
   *  Readable at sight to most contemporary programmers.
   *  Very much within the spirit of C & kith.
   *  Very concise -- no noise wasted on delaring in or out parameters.
      Only real noise is 'return' -- could we allow abbreviation to
        {$1+$2;}
      or perhaps
        {$1+$2}
      ? The former already has a legal interpretation as a null
      statement, while the latter will collide in some usages
      with vector constant notation -- {$1} is presumably how
      we want to write a one-slot vector literal, so at first blush
      the abbreviation looks dubious.
      LATER: I like using '^' as a synonym for 'return' better.
      That's short and does less violence to the notation, has
      some intuitive value (up arrow / returning result up) and
      I've seen it done in some other language.

*  'Self' has the pretty convention that any monadic fn f(x) can
   be equivalently written x.f.  There are definitely times when
   a.b.c.d is much nicer than d(c(b(a)));  I don't really feel up
   to making all accessors be functions and then inlining them to
   get back where we started, but the a->b notation is currently
   unused in MUC, we might consider turning it loose to represent
   monadic functions in this way...?  Might want to wait awhile and
   see if a better claim for the notation emerges, however...?

*  We might want to use "*a = *b;" notation for copying the contents
   of one array into another.  Ditto objects or structs.
     There might be one or two other places we could profitably use
   unary star notation.  Want to see what J does first, but maybe
      *a *= 2.0;
   would be a good way of doing a pointwise multiplication on a
   vector?  Seems more useful than leaving it as a synonym for
      a[0] *= 2.0;
   ? Or would this be the sort of odd special case that gets
   painful later on?  Does it generalize to cover the complete
   skandha4 set of pointwise expressions...?

*  Should we have an infix operator for cross-product?  'x'
   seems uninviting, axb could be an identifier.  How about
   'a><b'?  Is cross-product defined for other than three
   dimensional vectors?  Hard to see how, since there will
   be no unique perpendicular -- it would have to be a
   trinary operation in 4D, right?  The concept of volume
   of a parallelpiped defined by N-1 vectors in Nspace
   should work, and there should be a unique perpendicular
   to N-1 vectors, so generalizing to an (N-1)-ary operation
   should be ok.  This is likely just the determinant times
   the unit nullvector, or something like that?




/************************************************************************/
/*-    FOLLOW-ON PROJECTS						*/
/************************************************************************/
   

*  We may well need more things that behave like numbers by and
   by -- stuff like Quaternion and Fraction.  I expect BIGNUM
   will turn into a grabbag of these.  How we allow users to
   define new number types such as Polynomial is another question...?

*  We'll need public-key signatures at some point, to do broadcast
   trees to handle flashcrowds.  The Applied Crypto inverse-free
   algorithm in Schneier p498 (p-NEW) looks like a nice choice.

*  Be nice to have an FTP interface that worked by having a .ftp
   object which accepts "muq.org" or "128.95.128.15" type addresses
   and returns objects representing directories on that machine.
   This would allow browsing FTP sites via normal Muq browsing
   facilities. 
      The "next" function would probably have to be hacked
   to ignore all but explicitly mounted ftp sites, since iterating
   through the entire network is not reasonable.
      The same idea could be applied to other protocols,
   obviously.  For example, a .nfs object could index nfs-mounted
   filesystems, and a .http object could index websites.  A generic
   .url object is probably over-general, although a generic
   "getUrl" function would be a good idea.

*  Now wondering if it wouldn't make sense to
   o  Store large objects contiguously within .db files, using a separate
      large-object base address table of some sort;
   o  mmap() those objects into memory;
   The latter would allow sharing such objects with other processes,
   good for major voxel operations and such.  The former would keep
   them in sync with the rest of the db, and remove size ceilings.
   The whole scheme might be tied into the projected vm_Realloc()
   support.

*  Sort of following up the above, now wondering if it wouldn't make
   sense to copy all open db files into one large scratch file while
   running.  This way we would need only one open fd to access the
   dbs, plus an occasional second one to open, close or back up an
   individual db file.

*  Somewhat related to above, I'm starting to think of passing arrays
   through shared memory-mapped files as being a handy way of, for
   example, sharing point arrays with a 3D rendering subprocess like
   Skandha4.  In this context, it becomes a bothersome inconsistency
   that only large arrays are memory mapped.  This suggests a scheme
   in which perhaps the entire large scratchfile above is memory
   mapped, and a bigbuf bit indicates whether the active address
   should be taken as being in bigbuf, or as being in the memory
   mapped file.

*  We definitely need code to byte-swap a db file correctly at startup
   if it is the wrong sex.  Or perhaps while copying it into the large
   scratchfile, if we go that design route.

*  It would be good to add some more general-purpose datastructures to
   the standard shipping set at some point.  At the moment I have on
   my mind an index which supports multiple values per key, a bag
   implementation (multiple identical keys), an index supporting
   structured keys -- vectors? objects? stackblocks? -- an Objects
   class which indexs a set of objects by all their fields or some
   such, for very general database purposes, and an Rtree
   implementation for organizing spatial data.  Oh, and an object
   which lets one save and restore the state of an arbitrary object,
   for recursive wind-and-unwind sorts of search algorithms.

*  A 'policies' field (initially nil) on each object, plus a 'policies'
   field on Folk and Muq objects (a vanilla object) would be nice support
   for enacting more complex policies later.
     What I have in mind here is that when, say, we want to add a policy
   covering what objects are allowed to fart, we can define a 'mayFart?'
   generic function which
     * checks the object for an obj/policies/mayFart policy value;
     * if none, checks for obj%s/owner/policies/mayFart
     * if none, checks for /muq%s/policies/mayFart
     * if none, reverts to a default policy value.
     * If policy is a compiled function, calls it with
       [ :what obj  :may 'fart |  and returns result.
     * If policy is a Policy, calls generic function
       [ obj 'fart | may? and returns result.
     * Else returns the policy value itself as result.
   The notion is that we can establish a system-wide default policy on
   farting, then each player can establish a personal default for all
   her/his objects, and finally any individual object may have an
   override policy.
     The above is a quick sketch of an idea, details probably need work.

*  For 3D graphics, we will want to have a way of mirroring a remote
   array locally, probably transparently in the Proxy object.  (Perhaps
   a special ArrayProxy object?)  I expect this will involve something
   like:
   *  Keeping a generation number in the array and the proxy, so we can
      tell instantly if the proxy is out of date.
   *  Keeping a list of up to 32 (say) listeners per array which are
      notified when the array changes.  We need to limit this as spam
      protection.
   *  Probably, keeping a record of the last (say) 16 changes to the
      array.  (16 is the size of a 4x4 transform matrix, which is
      likely to be a major traffic item...?)
   *  Each array already (like every other object) has room for a TIMEOUT
      field.
   *  We can support a message specifically for polling the state of a
      matrix:  Each time a proxy array is accessed, if the value has
      not been confirmed as current within the last TIMEOUT seconds,
      a poll message can be sent to mirrored object.  The reply should
      likely contain:
        The current generation number.
        The current timeout value (it might have changed).
        The last 16 (or whatever updates).
   *  We can also support a message returning the hash values of some indicated
      subranges of the array:  This would allow the mirror to check for
      differences between the mirrored and original values without having
      to download all those values.
   *  Some mechanism to detect dead subscribers would be nice, so we can
      drop them.
   *  We need to ensure that the subscription mechanism doesn't reward
      users who flood us with subscription requests.  Preferably punishes
      them by moving them to the end of the queue waiting for a subscription.

     [Later]:  Here's another approach.  Remember heapsort and its
     implicit binary tree format?  Suppose we keep one generation number
     for each 4K block of data, each 8K block &tc, up to the root of the
     array.  Each time we update an array location, we also update all
     the generation numbers on the path to root.  (The root generation
     number always gets updated.)  We can of course optimize by not
     doing any of this (or even having the generation number table) when
     there are no watchers.
      Now, when a remote proxy queries us with its generation number, we
     can return a bitmap of all blocks which have been updated since its
     snapshot.  If we also return our root generation number with each
     block query to which we reply, it can also catch updates performed
     while it is updating.  Which might or might not be a good idea. :)
      If we also keep for each array the last time it was queried for a
     generation check, we might have a reasonable basis for clearing the
     "has watchers" flag.

       This scheme depends on the fact that arrays do not support
     insert and delete:  This keeps it from adapting directly to
     b-trees?  But we can still update generation numbers all the
     way to root if we want.  Querying for all updates past a given
     one is now more expensive, however.  Possibly we return only all
     generation numbers beneath a given block?  Or a bitmap of which
     ones are above the query generation number?

     [Still later:] In general, having only a bit on the object saying
     "I have watchers" and then keeping the generation numbers in a
     hashtable is Fairer.  In this particular context, it has the
     advantage that we don't have to swap in btree nodes just to check
     their generation numbers.  When someone starts watching an object,
     we can set the bit and then store in the hashtable generation
     numbers for nodes as they are modified.  If we also store the time
     at which we started watching, and use the timedate as our generation
     number, we can treat nodes with no generation numbers as having the
     starting time as their modification time...?  We may want to write
     the API so as to avoid returning explicit generation numbers in
     general, instead just returning TRUE/FALSE values indicating whether
     a block is younger/older than a query generation number, which in
     turn should probably be an opaque value to the caller. If we return
     the local current date/generation-number as part of each query
     response, these are available for later "activity since THEN"
     queries in opaque fashion.


   The motivating ideas of the above are:
   *  Allow local processing to proceed full-tilt using the proxy values,
      even if out of date.  For many 3D interactive graphics, an out of
      date image is still much better than no image at all.
   *  Allow the principal object to limit the load on itself by limiting
      the number of direct subscribers and limiting the polling period of
      the other subscribers.
   *  Allow proxy objects to stay in synch efficiently even if an occasional
      packet is lost:  Firing off the last 16 changes in each packet is meant
      to allow an occasional lost packet to be compensated for without needing
      any extra packets whatever.  Since often an extra hundred bytes or so
      in a packet add almost no extra communication cost (due to ethernet
      m inimum packet sizes &tc), adding some possibly useful extra info to
      each subscription packet seems like possibly a good win.  (Very slow
      serial connections might wish to renegotiatate this?)
   *  Allow mirroring proxies which come on line to reasonably efficiently
      resynch to the principal object, in particular without downloading
      the entire object if little has changed.


   * Can we avoid multiple proxies per server polling to mirror the
     same information?      

   An open question:  Should the subscription list, recent changes &tc for
   an array be stored in that array?  Or should they be in a central server
   hashtable or some such?
     Putting them in the array itself is simple, and if arrays are big, the
   overhead may not be significant.
     On the other hand, putting the info in a central hashtable would be
   Fairer, and if array mirroring works, we're likely to want to extend
   the idea to object mirroring and cons cell mirroring and such, and we
   definitely don't want to waste that much space in all of them on the
   offchance that they'll be mirrored at some point:  Hence, a central server
   hashtable looks more inviting in that case, and doing it that way for
   arrays also would add consistency to the implementation.  In this approach,
   we might perhaps want a single bit per object indicating whether it is
   mirrored, to save us doing a hashtable lookup every time we update a
   cons cell or structure, only to find out whether the object is being
   mirrored (which it presumably usually will not be).  If we follow this
   line of thought, it may make sense to also have a single PROXY bit in each
   such object, which makes it into a proxy -- check the central hashtable
   for the info on just where the primary object is?  This would add a one-bit
   check to each read from an object, but the result would be to make proxies
   very consistent with vanilla objects.  Since I'm pushing distributed computation
   as Muq's forte, slowing standalone operation to improve distributed operation
   is very thematic...

*  Should we add any hooks for supporting a hierarchical proa network?
   Seems like this should just require a parentIsle pointer, together
   with a convention that proas are built only to parents, siblings and
   children. This would seem to imply that parentIsle pointers are somehow
   exported, either in the build-proa command, or else perhaps via a new
   muqnet protocol message.  To avoid a single point of failure, we could
   have either an additional secondaryParentIsle pointer, or else a convention
   that if parentIsles is a vector, all components of the vector are parents...?
   The only essential hook would appear to be the parentIsle(s) pointer in the
   Micronesia world object.

*  Do we need to think at all about Skandha4 style animation support -- a perFrameHook
   guaranteed to be called once per frame?  Is this an example of something better
   handled by a global hashtable plus a one-bit field (recording the presence of
   a perFrameHook value in the hashtable)?  This seems a good example of functionality
   which we can offer above that provided by Java.

*  An existing example of procedurally generated worlds is discussed
   in http://www.gamasutra.com/features/19990917/infinite_01.htm
   "Algorithms for an Infinite Universe"

*  Why is it that programs explicitly provide GUI interfaces for
   users, but none for program maintainers?  Is it obvious that
   maintainance programmers are less deserving of a GUI, or less
   able to benefit from it, then end-users?  Or can we make
   explicitly addressing code maintainance issues as important a
   part of program design and implementation as end-use issues?
   Large programs have idiosyncratic techniques for performing
   various classes of changes, GUI encapsulations of them seem
   a reasonable proposition.  ?

*  Slow operations should probably update the current time, since
   (1) it is probably wrong after a slow operation and
   (2) the additional overhead is negligible.

*  A simple implementation of sparse arrays is just to use our b-trees
   with the linear coord as the key value, and a tiny tweak to do a
   delete instead of a set when storing a zero value.  Costs us a
   constant factor overhead for the keys, and slows access, of course.

*  A cheap way of handling creation and modification time info might be
   to keep them only on disk.  The first time an object is written to
   disk, bot creation and last-modified fields are set to the current
   time.  Thereafter when an object is written to disk, the
   last-modified time only is written with it.  This avoids having
   to store either in ram at all, we use only the dirty bit.  But
   still lets a sysadmin examine all objects created in some suspect
   interval or such.  Accessing the fields will always require a
   disk access, of course, which suggests that maybe it should not
   be done routinely -- instead of being vanilla properties, possibly
   they should be returned only by a special admin-only function...?
   [LATER]: Seems like a lot of overhead.  Tracking just creation and
   modified times for packages might be more to the point.

*  Kiczales's paper on efficient method dispatch in PCL has some
   interesting suggestions:  Are there any changes we should make
   as a result?  In particular, he uses class wrappers with hash
   seeds in them:  Do we need these?  Can we add them later?
   He also has a paper on the clos meta object protocol on the
   net:  Do we need to make any changes in response to it?
   He observes that auto-generated field read/write methods by
   far dominate CLOS, which is not surprising but also doesn't
   give me warm fuzzies...
    [LATER] Ok, just reread his paper relatively carefully. The
   main point of his having wrappers separate appears to be to
   distinguish between objects have/not been updating to reflect
   a new class definition. We're doing that via a 'next' pointer
   in keys. Our generic functions are just compiled functions,
   we can change them to have vectors used as memoization tables
   later if we want.  Hash values can be placed in reserved slots
   in keys if need be.  I see no upward compatibility issues here
   requiring attention pre-beta.

*  Strategically, Muq packages need I think to acquire most of the
   characteristics of RedHat or Debian packages:  Need to be
   independently installable units.  In particular, they likely need:
   + Major and minor version numbers. (String? Or float? Or two numbers? Or?)
   + Indication of where to download updates. (Will owner field do?)
   + Distinction between production and developer versions.
   + Policy settings controlling whether to update automatically,
     and if so whether to follow production or development branches.
   + Package dependency information: requires, supplies, replaces, ...?
   + Pre-install and post-install scripts?
   LATER: The above now applies more to db files than packages.
   
*  Do we need a COW bit in our pointers?  I'm thinking about the old
   problem of what to do with job properties when a job forks.
   Copying them all greedily is unpleasantly slow (but probably better
   than what we are doing?) so maybe setting a COW bit instead?  Would
   this also be useful for objects which inherit properties but do not
   modify their parents?  Is a special-purpose solution better, if
   this problem only affects jobs?  Is just doing the greedy copy the
   more sensible solution, at least for now? (I think so.)

*  At some point here we need hierarchical trust groups:  Anyone in
   group G can modify package P, where group G in turn incluses all
   the people in subgroup S.  How are we going to implement this?
   Should we mirror groups locally on each machine?  Hitting the net
   for every permission check is likely to be unacceptably slow.
   Should a trust group masquerade as a new user, so that we make our
   requests appear to come from the group pseudo-user, avoiding the
   server having to be globally group-aware?  Or does this lose the
   identity of the actual user doing the operation in a harmful way?

*  Package access fields.  For collaboration, may wish to issue rights
   to various other users to read and or modify a package as though
   they were the owner.  My current thought is that it is best to have
   a B-tree of users.  Do we want to support stuff like "this user can
   modify this package except when the regression test is running?"
   If so, we need a generic function as well or instead that passes
   judgement on access attempts.  Should package access be treated as a
   more global form of capability, with the API harmonized?  Should we
   have a still more global form of capability covering all the possessions
   of a given user?

*  Be great fun to make Muq dbs be Linux filesystems.  This would
   allow using the existing Unix toolset including emacs on Muq dbs
   in a natural way.


Be nice to read the Golgotha source (http://www.crack.com/golgotha_release/)
that crack.com released and see if there are any inspiring ideas there.

Be nice to keep shared secret generation from locking up all of muqnet
until complete:  Either put it in a separate job (relatively easy) or
timeslice during exptmods (relatively hard).

If at all possible, it would still be very nice to segment the db into
system packages that contain only stuff that never changes, vs Var packages
which contain just the locally modified stuff:  One can then eaily imagine
automatically moving the Var stuff to a local db segment when db
segmentation arrives.

SOME LATER THOUGHTS:  
  (1) 'part' is a shorter name than 'segment'.
  (2) Having both 'packages' and 'segments/parts' may be more user-visible
      complexity than can be justified.  Why not just have each package be
      a part/segment/file and be done with it?
  (3) One pleasant side-effect of this would seem to be that we would
      no longer need an explicit 'package' pointer in every non-immediate
      value.
  (4) For sanity, one probably wants to adopt the rule that garbage
      collection does NOT function across package boundaries.  Otherwise,
      we can't gc a package unless all packages referring to it are online,
      which is going to be a nightmare in a large distributed context where
      packages get mounted and dismounted and archived and rolled back to
      previous versions &tc.  Packages should use proxies for all references
      to other packages?  That could be a lot of big, expensive proxies.
      Possibly we can use local 64-bit pointers when referring to objects
      in local packages?  Or at minimum, when referring to the local base
      packages like muf: ?


One I'd particularly like to see is local mirroring of remote packages.
Ideally, this would allow mirroring of both the db package and also
any associated native methods.

Possibly the unit of mirroring should be the db segment rather than the
package, once we have support for segmenting the db?  (16 bits of db
identifier is probably about right, in my opinion of the moment. 65536
is a lot of db segments.  1024 isn't many, and takes already 10 bits:
a silly six extra bits gets us to 64K.  256 would be a really small
number:  Might work in practice, but seems like it might be pushing
it hard and in dire danger of winding up being a regrettable restriction.)
  --> maybe installation of a mirrored db segment should proceed by
      1)  Mount the new segment with a new segment number.
      2)  Pass through the db changing all pointers to the old segment
          to point to the new segment.  If any pointers cannot be
          converted, this can then be backed out.
      3)  Repeat (2) until no more pointers remain to the old segment,
          or some limit is reached?  (Since new pointers may have been
          created in the meantime, barring special support hacks.)
      4)  Dismount the new segment.
  Problem with this is that remote proxies to objects will never get
  changed over to the new segment number.  So somehow we need to wind
  up in the end with the new segment mounted under the old segment
  number.  Hrm... :-/  Maybe initially this should be a semi-offline
  process where the server stays up but stops all processing other
  than the switch-over until the switchover is complete.

-> WE SHOULD MAYBE AVOID exporting db numbers if we go to supporting
   multiple dbs per server:  We'll be needing to renumber dbs from time
   to time (when a user moves between servers, say, and collides with
   a pre-existing db number there), and this renumbering should be
   practical as long as we keep the number local.  Suppressing that
   field in exported ids swill make lookup a bit more expensive
   when importing a native pointer: We'll have to look up in each open
   db, at worst.  (The guard bits will catch collisions, of course.)
   LATER THOUGHT: This looks like a nightmare.  I'm inclined to instead
   provide more db numbers, and strenuously avoid renumbering.

-> Can we allow one flyweight class per package?  I'm thinking of Flyweights
   as being immediate values containing a ca 32-bit immediate integer,
   plus a package identifier -- object format, with the immediate integer
   in the offset field, but with a distinguishing tag.  The corresponding
   class definition would be found via a slot in the package object. This
   could be used, for example, to implement Unicode characters together
   with some font/color/etc information as normal-appearing class instances, but
   taking only an 8-byte immediate value each.
     The point is that we hardwire support for immediate values like
   chars, floats, fixnums &tc, and that it would be nice to allow the
   app hacker to similarly create classes of immediate values.

-> We should now actually have enough bits to make ephemerals visible
   outside of the host thread:  Just include both a a thread number
   and a stack offset.  Dunno if this is a good idea.  Working on
   improving garbage collection might be more to the point than more
   effort on ephemeral support...

-> Design Pattern's observation that creating an instance of a class
   by specifying a hardwired constant class is anathema suggests that
   we should implement a system-wide solution once rather than asking
   the app hacker to hand-code a work-around every time something is
   created.
     One obvious try is to have a per-user table mapping classes
   to substitute classes.  A user can then specify that locally
   MyFancyWidget should always be used instead of ThatPlainWidget.
   (Doing this based on the effective user will avoid some nasty
   security issues.)
     One might occasionally wish to have a more specific override
   which changes only the class created by one particular subroutine.



What happens when a db file migrates from one server to another?
Should we iterate through all local dbs, converting pointers to
proxies?  That would be slow.  Should we do something in vm_Loc()
to make pointers to them look like proxies?  That seems a bit hairy.
Best hack might be to convert all pointers in memory, and then
process objects as they swap in, converting obsoleted pointers into
appropriate proxies...? But we need some way of knowing when we're
done.  (LATER: Also, if we go to memory-mapping for big objects, there
won't always be a swap-in time.)


/************************************************************************/
/*-    SIGNALS / WATCHING / FLASHCROWD-PROOFING				*/
/************************************************************************/
   
*  It has belatedly occurred to me that we don't have a simple, natural
   solution for the one-writes/everyone-reads-everything situation:
   Message streams are set up so that each packet gets read by exactly
   one reader, but we would like a trivial API that makes it possible
   for each packet to get read by every reader.
     The simplest and most natural (from the application programmer's
   point of view) solution, it now occurs to me, might be just to have a
     mss.everyoneReadsEverything
   flag on message streams which can simply be set non-nil, after
   which everyone reading from it gets every message.
     That leaves "just" the problem of implementing the required
   functionality, while ensuring that no antisocial reader can stop
   everything in its tracks.  That pretty clearly implies that setting
   the flag makes the messageStream unreliable:  To guarantee no
   lockup, we have to drop the guarantee that every packet gets
   delivered to every reader, settling instead (?) for a guarantee
   that every packet gets delivered to at least one reader.
     As part of that implementation, we can do the flashcrowd
   proofing that constructs trees of clients so as to ensure that
   an unbounded number of clients can be served with a bounded
   load on the server -- this API provides a splendid way of
   hiding all the mechanics of that from the application programmer.
     One apparent consequent of all this is that WE SHOULD ADD A SERIAL
   NUMBER TO EVERY PACKET PASSING THROUGH A MESSAGESTREAM:  This is
   needed in the tree form to detect missing packets and allow for
   a way of requesting retransmission of them.  This wouldn't actually
   require adding a serial number to every packet internal to a
   messageStream, of course, it would be sufficient to maintain
   a count of packets entered into the messageStream so far, and
   then count from there when need be.

*  There's a bunch of existing and planned stuff that could be
   profitably pulled together under the umbrella of the condition
   system, I think:

   o  Reading input queues should maybe be at least optionally viewed
      as a matter of setting a condition handler.  Can the underlying
      implementations of streams and conditions be merged usefully?

   o  Muqnet and micronesia incoming packets could be condition
      handlers instead of stream reads followed by ad hoc branches
      as they are now?

   o  'Watching' is one of the Design Patterns, and really should
      have generic inserver support.  It would be nice to fit this
      into the condition system:  Every object becomes conceptually
      a source of events such as wroteField or whatever, and other
      objects can establish handlers for those events.  From the
      user API point of view, this really seems to just require
      adding an optional eventSource argument to the handler-establishing
      calls.

   o  Flashcrowd proof notification should ideally be just an
      extension of the above generic watcher facility:  To tune
      in a public channel, we just establish a condition handler
      for send events from the appropriate object on the remote
      Muq server and -- voila -- we get copied on the posts.
      We'd like the flashcrowd proofing to be a transparent part
      of the underlying muq/muqnet implementation.  (LATER:  Or
      see the idea of an everyone-reads hack on messageStreams.
      Event handlers would introduce more need for locking than
      would the messageStream approach, since the context in
      which they run is less predictable.  Comes down to whether
      we think a job per subscription is reasonable, which
      clearly depends on the application in mind... probably
      we need to support both?)

   o  Mirroring would ideally be built directly on the above.
      Something like: Every proxy registers itself for modification
      events on the proxied original, which events then get fanned
      out via the flashcrowd proofing if need be.
        Open questions:

      x  What happens when events get generated
         faster than the notification channel can accept them? Clearly
         a tight local loop can update a field faster than the network
         can accept packets, say.  Presumably we number events, drop
         overflow events, and listeners note gaps in the sequence?
          This opens the way to malicious dropping of events actually
         sent, though, unless we number events generated vs event
         notifications transmitted separately.  Proxies then need a
         protocol for re-synching after a known gap.  To be flashproof,
         this really needs to involve periodic transmits of the entire
         original object state, perhaps as part of the heartbeat?

      x  Should the proxy cache be local to a user or global to a
         server?  If it is local to a user, we can wind up caching
         the same large object many times, which is unpleasant.
         How do we avoid getting spammed by mirrors of large objects?
         An index of the human genome, say?

      x  Should a cache update itself constantly, or only while in
         use?  When it is believed to be stale, should access to it
         block?  Should we worry at all about consistency issues?

      x  Does proxy behavior need to be per-class programmable?
         This might be the way to handle consistency sorts of
         issues?  Or does this open the door too wide to malicious
         outsiders?

      x  If events are often generated on one server and processed
         on another, but objects travel only by proxy, is it then
         presumably a bad idea to make events be objects?  The
         packet of keyval pairs travels better.  How about keying
         event handlers on a class lattice?  Being able to handle
         entire classes of events is nice, but can we do that
         cross-server in practice?  Is the current mechanism
         efficient enough for heavy use?  Do we need special case
         handlers and signals which are cheaper?

      NB: I've established a vm.t WATCHED bit for signalling that
      an object has external watchers who would like to recieve
      events relating to it.

   o  Can/should TELNET protocol handling be recast as condition
      handling, in place of the current ad-hoc dispatch mechanism?
      Do we really need a separate telnet daemon, or should it be
      merged into the main task daemon?  Note that a given user
      might have many telnet sessions open at a given time: One
      daemon job per connection is cleaner than having them all
      handled by one, which must then explicitly handle multiple
      states?

   o  Can/should debugger support be cast as a matter of establishing
      handlers for events from the debugged job(s)?  Breakpoints, at
      least, clearly go beyond the vanilla condition paradigm: The
      job needs to immediately halt when hitting one, not merely
      generate an event.  But possibly we cast breakpoints as
      properties to be set on job objects, and have the job generate
      events after that?

   o  It might (?) be logical to implement the GUI API, when it arrives,
      also in terms of the condition system -- "event-driven" is the
      usual paradigm for GUI programming these days, and event
      handling is really what the condition system is all about.
      So widgets would become objects which generate events which
      can be monitored by jobs via signal handlers, yet again.
        This notion suggests that just as it is nice to have one
      handler able to process entire classes of events, so it
      might be nice to let one handler process an entire set of
      event sources -- all the buttons on a panel?  Or should
      this be handled by having all events from buttons on the
      panel also become panel events, and we then subscribe to
      the entire panel?
        ISSUE:  GUI event handlers usually have the notion of
      an event being "handled":  The substrate tries handler
      after handler until one indicates that the problem is
      'handled'.  The CommonLisp condition system has similar
      provisions, but using them implies that we need to think
      in terms of the job subscribing to an event source, and
      then the entire cascade of event handlers being unleashed
      upon each event recieved.  This militates against seeing
      subscription to an event source as being something
      associated with setting a particular handler:  Subscription
      is either statically global to an entire job or else bound
      by a different type of stackframe.  If everything else is
      going to support both static btrees of bindings and also
      dynamic stackframe bindings, perhaps subscriptions should
      also?
        ISSUE:  What happens to an event subscription when the
      job forks?  Presumably both jobs are now subscribed to
      the event source?  If so, the intra/inter server delivery
      service needs to be able to handle this smoothly: Delivery
      routes cannot be static lists of jobs...?  Or adding the
      child job to such subscription lists must be part of the
      fork processing.



/************************************************************************/
/*-    Musings								*/
/************************************************************************/

Abstractly, arguments may be best understood as function invocation
modifiers:
  We can think of a function F which takes arguments A, B, C
defaulting to 0,0,0 as having as its primitive invocation just
  F
returning some value, while invocations such as
  (A==3)F
consist of F invoked with A set to 3 instead of the default 0.
 So should we have a language in which positionally declared
parameters get default names A,B,C... and in which named arguments
can be set by position...?




   
/************************************************************************/
/*-    98Sep06 Premature timeout log (buggo)				*/
/************************************************************************/
   
-------------------------------------------------------------------------------------------
SAVED MUQ.LOG, 98Sep06  (buggo)
 This shows two premature timeouts, marked by "*****".  Log was generated by adding 
  [ "]request/aaa op=%s taskId=%d delay=%d" op taskId delay | ]print log,
to pkq/347-W-oldrequest.t:]request and
  [ "]requestTimeoutFn/aaa op=%s taskId=%d delay=%d" op taskId delay | ]print log,
to pkq/347-W-oldrequest.t:]requestTimeoutFn and then running "rm -rf #check.tmp ; make check".
  Both premature timeouts happened on REQ_IS_HELD_BY requests initiated at .003 seconds.
  There were 71 other REQ_IS_HELD_BY requests which worked fine.
  There were no other requests initiated at 0.003 seconds.
  There were no requests initiated at 0.001 seconds.
  There was one REQ_IS_HELD_BY request initiated at 0.002 seconds: It worked correctly.
  There were no requests initiated at 0.004 seconds.
Looks like there's something a bit squirrelly in our sleep queue logic or some such?
For now, this looks to be just a minor efficiency bug, so I'll delay investigation to
post-beta.


-----------------------
date:1998/09/06/07:34:48.362 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 16941)
date:1998/09/06/07:34:51.513 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 100-millisec garbage collect #1 recovered 34 objects 9136 bytes, left 5347 objects, 745083 bytes
date:1998/09/06/07:34:53.225 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 137-millisec garbage collect #2 recovered 3037 objects 445583 bytes, left 5606 objects, 801149 bytes
date:1998/09/06/07:34:54.175 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 129-millisec garbage collect #3 recovered 1674 objects 452212 bytes, left 5754 objects, 853300 bytes

date:1998/09/06/07:34:54.961 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 166-millisec garbage collect #4 recovered 1323 objects 475175 bytes, left 5852 objects, 880203 bytes
date:1998/09/06/07:34:56.144 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 241-millisec garbage collect #5 recovered 495 objects 486158 bytes, left 5904 objects, 896749 bytes
date:1998/09/06/07:34:56.539 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 127-millisec garbage collect #6 recovered 672 objects 493532 bytes, left 5907 objects, 903242 bytes
date:1998/09/06/07:34:57.299 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 136-millisec garbage collect #7 recovered 1518 objects 467619 bytes, left 6048 objects, 935774 bytes

date:1998/09/06/07:34:57.996 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 161-millisec garbage collect #8 recovered 1564 objects 467465 bytes, left 6205 objects, 981148 bytes
date:1998/09/06/07:34:58.549 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 135-millisec garbage collect #9 recovered 963 objects 489867 bytes, left 6346 objects, 998472 bytes
date:1998/09/06/07:34:59.529 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 152-millisec garbage collect #10 recovered 2238 objects 475926 bytes, left 6463 objects, 1025328 bytes
date:1998/09/06/07:35:01.169 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 278-millisec garbage collect #11 recovered 2283 objects 435018 bytes, left 6843 objects, 1092704 bytes

date:1998/09/06/07:35:02.531 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 164-millisec garbage collect #12 recovered 2279 objects 460473 bytes, left 6986 objects, 1136772 bytes
date:1998/09/06/07:35:03.639 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 170-millisec garbage collect #13 recovered 2240 objects 444653 bytes, left 7276 objects, 1196664 bytes
date:1998/09/06/07:35:04.083 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 159-millisec garbage collect #14 recovered 668 objects 482065 bytes, left 7342 objects, 1215521 bytes
date:1998/09/06/07:35:04.789 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 359-millisec exptmod done

date:1998/09/06/07:35:05.194 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 402-millisec exptmod done
date:1998/09/06/07:35:05.683 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 485-millisec exptmod done
date:1998/09/06/07:35:06.091 muq:198.161.029.208:30000 job:0260000015 user:                 msg: 403-millisec exptmod done
date:1998/09/06/07:35:06.539 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 174-millisec garbage collect #15 recovered 1374 objects 447219 bytes, left 7522 objects, 1268354 bytes

date:1998/09/06/07:35:07.072 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 186-millisec garbage collect #16 recovered 857 objects 479298 bytes, left 7589 objects, 1293818 bytes
date:1998/09/06/07:35:07.947 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 181-millisec garbage collect #17 recovered 1256 objects 440361 bytes, left 7996 objects, 1353623 bytes
date:1998/09/06/07:35:09.157 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 209-millisec garbage collect #18 recovered 2037 objects 460646 bytes, left 8326 objects, 1403734 bytes
date:1998/09/06/07:35:09.968 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 227-millisec garbage collect #19 recovered 461 objects 489601 bytes, left 8361 objects, 1433133 bytes

date:1998/09/06/07:35:10.358 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 179-millisec garbage collect #20 recovered 380 objects 490708 bytes, left 8375 objects, 1446284 bytes
date:1998/09/06/07:35:10.839 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 180-millisec garbage collect #21 recovered 436 objects 504698 bytes, left 8412 objects, 1453808 bytes
date:1998/09/06/07:35:11.859 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 509-millisec garbage collect #22 recovered 1371 objects 489233 bytes, left 8489 objects, 1475918 bytes
date:1998/09/06/07:35:12.379 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 184-millisec garbage collect #23 recovered 971 objects 482863 bytes, left 8593 objects, 1493705 bytes

date:1998/09/06/07:35:12.886 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 185-millisec garbage collect #24 recovered 856 objects 477080 bytes, left 8663 objects, 1526305 bytes
date:1998/09/06/07:35:13.623 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 195-millisec garbage collect #25 recovered 1546 objects 461003 bytes, left 8861 objects, 1565956 bytes
date:1998/09/06/07:35:14.277 muq:198.161.029.208:30000 job:0260000015 user:root             msg: 193-millisec garbage collect #26 recovered 1270 objects 472146 bytes, left 8970 objects, 1594407 bytes
date:1998/09/06/07:35:16.024 muq:198.161.029.208:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 16941)

date:1998/09/06/07:35:16.627 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 16974)
date:1998/09/06/07:35:23.448 muq:198.161.029.208:30000 job:5560000015 user:root             msg: 499-millisec garbage collect #1 recovered 966 objects 353147 bytes, left 9439 objects, 1742223 bytes
date:1998/09/06/07:35:25.712 muq:198.161.029.208:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 16974)
date:1998/09/06/07:35:30.836 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17240)
date:1998/09/06/07:35:40.586 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 648-millisec garbage collect #1 recovered 823 objects 272529 bytes, left 10302 objects, 1970799 bytes
date:1998/09/06/07:35:58.893 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 277-millisec garbage collect #2 recovered 1042 objects 160888 bytes, left 11891 objects, 2312908 bytes
date:1998/09/06/07:36:07.688 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 307-millisec garbage collect #3 recovered 1115 objects 280239 bytes, left 12822 objects, 2532982 bytes

date:1998/09/06/07:36:12.648 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 330-millisec garbage collect #4 recovered 1292 objects 324782 bytes, left 13529 objects, 2709434 bytes
date:1998/09/06/07:36:18.442 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 353-millisec garbage collect #5 recovered 1203 objects 309846 bytes, left 14252 objects, 2899640 bytes
date:1998/09/06/07:36:22.172 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 396-millisec garbage collect #6 recovered 1290 objects 352673 bytes, left 14902 objects, 3047531 bytes
date:1998/09/06/07:36:28.352 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 396-millisec garbage collect #7 recovered 1355 objects 340277 bytes, left 15573 objects, 3208084 bytes

date:1998/09/06/07:36:33.638 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 434-millisec garbage collect #8 recovered 1192 objects 338668 bytes, left 16111 objects, 3369480 bytes
date:1998/09/06/07:36:40.147 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 435-millisec garbage collect #9 recovered 1470 objects 348094 bytes, left 16871 objects, 3523170 bytes
date:1998/09/06/07:36:49.116 muq:198.161.029.208:30000 job:3660000015 user:root             msg: 563-millisec garbage collect #10 recovered 1771 objects 330995 bytes, left 17755 objects, 3692637 bytes
date:1998/09/06/07:36:55.287 muq:198.161.029.208:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17240)

date:1998/09/06/07:36:56.754 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17305)
date:1998/09/06/07:36:58.706 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Arithmetic tests
date:1998/09/06/07:37:06.575 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Bignum tests
date:1998/09/06/07:37:12.159 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 1271-millisec garbage collect #1 recovered 3346 objects 522856 bytes, left 18045 objects, 3670042 bytes

date:1998/09/06/07:37:14.549 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 17-millisec exptmod done
date:1998/09/06/07:37:15.651 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 445-millisec exptmod done
date:1998/09/06/07:37:16.315 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 603-millisec exptmod done
date:1998/09/06/07:37:20.808 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 4407-millisec exptmod done

date:1998/09/06/07:37:43.890 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 23013-millisec exptmod done
date:1998/09/06/07:37:50.317 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 369-millisec exptmod done
date:1998/09/06/07:37:50.745 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 368-millisec exptmod done
date:1998/09/06/07:37:51.249 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 443-millisec exptmod done

date:1998/09/06/07:37:51.653 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 343-millisec exptmod done
date:1998/09/06/07:37:52.375 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 342-millisec exptmod done
date:1998/09/06/07:37:52.778 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 341-millisec exptmod done
date:1998/09/06/07:37:53.828 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Binding tests

date:1998/09/06/07:37:54.722 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Compile support tests
date:1998/09/06/07:37:55.478 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 523-millisec garbage collect #2 recovered 4050 objects 439630 bytes, left 18120 objects, 3730595 bytes
date:1998/09/06/07:38:00.867 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 622-millisec garbage collect #3 recovered 1025 objects 463498 bytes, left 18135 objects, 3767286 bytes
date:1998/09/06/07:38:02.103 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 481-millisec garbage collect #4 recovered 163 objects 522216 bytes, left 18138 objects, 3784294 bytes

date:1998/09/06/07:38:03.124 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 490-millisec garbage collect #5 recovered 101 objects 515586 bytes, left 18149 objects, 3786184 bytes
date:1998/09/06/07:38:04.198 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 493-millisec garbage collect #6 recovered 101 objects 515618 bytes, left 18148 objects, 3786126 bytes
date:1998/09/06/07:38:05.165 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 484-millisec garbage collect #7 recovered 100 objects 515560 bytes, left 18148 objects, 3786126 bytes
date:1998/09/06/07:38:06.796 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 643-millisec garbage collect #8 recovered 103 objects 515763 bytes, left 18155 objects, 3787182 bytes

date:1998/09/06/07:38:07.856 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 461-millisec garbage collect #9 recovered 115 objects 516790 bytes, left 18176 objects, 3791286 bytes
date:1998/09/06/07:38:08.862 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 484-millisec garbage collect #10 recovered 120 objects 516904 bytes, left 18177 objects, 3791376 bytes
date:1998/09/06/07:38:09.994 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 598-millisec garbage collect #11 recovered 124 objects 517131 bytes, left 18179 objects, 3791534 bytes
date:1998/09/06/07:38:11.049 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 573-millisec garbage collect #12 recovered 126 objects 517351 bytes, left 18179 objects, 3791555 bytes

date:1998/09/06/07:38:12.140 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Condition system tests
date:1998/09/06/07:38:17.443 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 512-millisec garbage collect #13 recovered 614 objects 496674 bytes, left 18210 objects, 3794978 bytes
date:1998/09/06/07:38:19.405 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Debugger support function tests
date:1998/09/06/07:38:21.457 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Ephemeral list tests

date:1998/09/06/07:38:22.606 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Ephemeral structure tests
date:1998/09/06/07:38:24.603 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Ephemeral vector tests
date:1998/09/06/07:38:25.819 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Control structure and variables tests
date:1998/09/06/07:38:28.095 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Lambda-list tests

date:1998/09/06/07:38:33.406 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Lisp reader #-macro tests
date:1998/09/06/07:38:33.658 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Lisp printer tests
date:1998/09/06/07:38:33.956 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: MOS (Muq Object System) support tests
date:1998/09/06/07:38:35.205 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 527-millisec garbage collect #14 recovered 3344 objects 466842 bytes, left 18577 objects, 3828223 bytes

date:1998/09/06/07:38:48.117 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 700-millisec garbage collect #15 recovered 3234 objects 408923 bytes, left 19077 objects, 3919419 bytes
date:1998/09/06/07:38:57.616 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Multi-thread facilities tests
date:1998/09/06/07:38:58.242 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 553-millisec garbage collect #16 recovered 2831 objects 426144 bytes, left 19467 objects, 3993564 bytes
date:1998/09/06/07:39:30.828 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Muqnet support tests

date:1998/09/06/07:39:36.345 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 535-millisec garbage collect #17 recovered 1184 objects 219634 bytes, left 19507 objects, 4021867 bytes
date:1998/09/06/07:39:37.422 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Nanomud tests
date:1998/09/06/07:39:37.844 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 351-millisec exptmod done
date:1998/09/06/07:39:38.182 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 331-millisec exptmod done

date:1998/09/06/07:39:38.692 muq:198.161.029.208:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1135 (local port 32000)
date:1998/09/06/07:39:39.677 muq:198.161.029.208:30000 job:6260000015 user:root             msg: 568-millisec garbage collect #18 recovered 288 objects 72656 bytes, left 19709 objects, 4466193 bytes
date:1998/09/06/07:39:40.600 muq:198.161.029.208:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1137 (local port 32000)
date:1998/09/06/07:39:42.088 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:32000 (local port 1135)

date:1998/09/06/07:39:42.125 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:1135 (local port 32000)
date:1998/09/06/07:39:42.210 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:32000 (local port 1137)
date:1998/09/06/07:39:42.212 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:1137 (local port 32000)
date:1998/09/06/07:39:42.399 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Basic object tests

date:1998/09/06/07:39:42.960 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Rex tests
date:1998/09/06/07:39:44.648 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 628-millisec garbage collect #19 recovered 891 objects 125519 bytes, left 19812 objects, 4840677 bytes
date:1998/09/06/07:39:48.542 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Socket tests
date:1998/09/06/07:39:48.984 muq:198.161.029.208:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1138 (local port 32123)

date:1998/09/06/07:39:49.485 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:1138 (local port 32123)
date:1998/09/06/07:39:49.486 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:32123 (local port 1138)
date:1998/09/06/07:39:50.432 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 669-millisec garbage collect #20 recovered 2311 objects 266913 bytes, left 19902 objects, 5098941 bytes
date:1998/09/06/07:39:52.634 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Stack operator tests

date:1998/09/06/07:39:53.423 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Message stream tests
date:1998/09/06/07:39:56.680 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 696-millisec garbage collect #21 recovered 562 objects 416227 bytes, left 19939 objects, 5205537 bytes
date:1998/09/06/07:40:01.930 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Structure operator tests
date:1998/09/06/07:40:13.341 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: 933-millisec garbage collect #22 recovered 2751 objects 445202 bytes, left 20377 objects, 5260472 bytes

date:1998/09/06/07:40:13.932 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Telnet protocol support tests
date:1998/09/06/07:40:14.335 muq:198.161.029.208:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1140 (local port 32122)
date:1998/09/06/07:40:16.577 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:1140 (local port 32122)
date:1998/09/06/07:40:16.579 muq:198.161.029.208:30000 job:           user:root             msg: TCP disconnect from 127,0.0.1:32122 (local port 1140)

date:1998/09/06/07:40:16.802 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Root/User/Guest support tests
date:1998/09/06/07:40:17.063 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: Whimsical tests
date:1998/09/06/07:40:22.587 muq:198.161.029.208:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17305)
date:1998/09/06/07:40:22.927 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17348)
date:1998/09/06/07:40:24.009 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17364)
date:1998/09/06/07:40:26.464 muq:198.161.029.208:30000 job:6e60000015 user:root             msg: xy-muqnet2 starting...
date:1998/09/06/07:40:27.696 muq:127.000.000.001:40000 job:6e60000015 user:root             msg: 788-millisec exptmod done
date:1998/09/06/07:40:27.787 muq:198.161.029.208:30000 job:7360000015 user:root             msg: xx-muqnet2 starting...
date:1998/09/06/07:40:28.466 muq:127.000.000.001:40000 job:6e60000015 user:root             msg: 767-millisec exptmod done

date:1998/09/06/07:40:29.152 muq:127.000.000.001:40000 job:6e60000015 user:root             msg: 684-millisec exptmod done
date:1998/09/06/07:40:29.923 muq:127.000.000.001:40000 job:6e60000015 user:root             msg: 758-millisec exptmod done
date:1998/09/06/07:40:30.861 muq:127.000.000.001:40000 job:6e60000015 user:root             msg: 914-millisec exptmod done
date:1998/09/06/07:40:31.271 muq:127.000.000.001:40000 job:6760000015 user:root             msg: muqnet:run Starting up.

date:1998/09/06/07:40:31.402 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 3504-millisec garbage collect #1 recovered 995 objects 221299 bytes, left 20510 objects, 5631043 bytes
date:1998/09/06/07:40:31.405 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet:run Starting up.

date:1998/09/06/07:40:37.541 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 338-millisec exptmod done
date:1998/09/06/07:40:37.975 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 429-millisec exptmod done
date:1998/09/06/07:40:37.978 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet/doAckMuqnetUserInfo: Updating muqnet hashname 2193868752508776488
date:1998/09/06/07:40:39.769 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 363-millisec exptmod done
date:1998/09/06/07:40:39.771 muq:127.000.000.001:40000 job:6760000015 user:root             msg: muqnet: Packet from unknown hashname 1484424047586484190, dropping packet & requesting info
date:1998/09/06/07:40:40.140 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 363-millisec exptmod done
date:1998/09/06/07:40:40.144 muq:127.000.000.001:40000 job:6760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 1484424047586484190 (foregroundRoot)

date:1998/09/06/07:40:42.531 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 342-millisec exptmod done
date:1998/09/06/07:40:42.535 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet: Packet mentions unknown hashname 2156763317633676853, dropping packet & requesting info

date:1998/09/06/07:40:42.883 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 345-millisec exptmod done
date:1998/09/06/07:40:43.231 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 343-millisec exptmod done
date:1998/09/06/07:40:43.235 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 2156763317633676853 (backgroundRoot)
date:1998/09/06/07:40:45.921 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 364-millisec exptmod done
date:1998/09/06/07:40:46.497 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 351-millisec exptmod done
date:1998/09/06/07:40:46.885 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 384-millisec exptmod done

date:1998/09/06/07:40:48.512 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 329-millisec exptmod done

date:1998/09/06/07:40:48.514 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet: Packet from unknown hashname 846270541731794958, dropping packet & requesting info
date:1998/09/06/07:40:48.848 muq:127.000.000.001:40000 job:6760000015 user:root             msg: 330-millisec exptmod done
date:1998/09/06/07:40:49.215 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 363-millisec exptmod done
date:1998/09/06/07:40:49.218 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 846270541731794958 (terry)
date:1998/09/06/07:40:50.592 muq:127.000.000.001:30000 job:3760000015 user:root             msg: 364-millisec exptmod done

date:1998/09/06/07:40:52.567 muq:127.000.000.001:30000 job:3760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 846270541731794958 (terry)
date:1998/09/06/07:40:56.925 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 870-millisec garbage collect #2 recovered 540 objects 289820 bytes, left 20744 objects, 5794208 bytes
date:1998/09/06/07:40:58.905 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 781-millisec garbage collect #3 recovered 14 objects 10128 bytes, left 20747 objects, 5828792 bytes
date:1998/09/06/07:41:01.130 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 839-millisec garbage collect #4 recovered 25 objects 88790 bytes, left 20747 objects, 5828792 bytes

date:1998/09/06/07:41:03.419 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 663-millisec garbage collect #5 recovered 41 objects 176950 bytes, left 20747 objects, 5828792 bytes
date:1998/09/06/07:41:06.232 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 795-millisec garbage collect #6 recovered 73 objects 353271 bytes, left 20747 objects, 5828792 bytes
date:1998/09/06/07:41:09.922 muq:127.000.000.001:30000 job:7360000015 user:root             msg: 684-millisec garbage collect #7 recovered 137 objects 705911 bytes, left 20747 objects, 5828792 bytes
date:1998/09/06/07:41:15.222 muq:127.000.000.001:30000 job:7360000015 user:root             msg: xx-muqnet2 done.

date:1998/09/06/07:41:20.875 muq:127.000.000.001:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17364)
date:1998/09/06/07:41:21.011 muq:127.000.000.001:40000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17348)
date:1998/09/06/07:41:21.088 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17403)
date:1998/09/06/07:41:22.136 muq:127.000.000.001:30000 job:           user:                 msg: MUQ STARTING. (pid 17422)
date:1998/09/06/07:41:25.457 muq:198.161.029.208:40000 job:7360000015 user:root             msg: 2898-millisec garbage collect #1 recovered 639 objects 531716 bytes, left 18032 objects, 3681903 bytes
date:1998/09/06/07:41:26.343 muq:198.161.029.208:40000 job:7360000015 user:root             msg: xy-oldmud2 starting...
date:1998/09/06/07:41:26.466 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Installing new longNames...

date:1998/09/06/07:41:27.320 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 707-millisec exptmod done
date:1998/09/06/07:41:28.101 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 769-millisec exptmod done
date:1998/09/06/07:41:28.525 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 422-millisec exptmod done
date:1998/09/06/07:41:28.929 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 402-millisec exptmod done

date:1998/09/06/07:41:29.293 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 361-millisec exptmod done
date:1998/09/06/07:41:29.577 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Starting muqnet...
date:1998/09/06/07:41:29.585 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet:run Starting up.
date:1998/09/06/07:41:29.592 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Making sample isle...

date:1998/09/06/07:41:30.074 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 392-millisec exptmod done
date:1998/09/06/07:41:30.931 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 776-millisec exptmod done
date:1998/09/06/07:41:33.099 muq:127.000.000.001:40000 job:7360000015 user:root             msg: 2090-millisec garbage collect #2 recovered 396 objects 67506 bytes, left 18557 objects, 4124319 bytes
date:1998/09/06/07:41:33.790 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Starting isle daemons...

date:1998/09/06/07:41:34.476 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:36.068 muq:127.000.000.001:40000 job:7360000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1286133147142494092 delay=1000
date:1998/09/06/07:41:36.069 muq:127.000.000.001:40000 job:7360000015 user:root             msg: ]request/aaa taskId = -1286133147142494092
date:1998/09/06/07:41:36.080 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Started isle daemons...

date:1998/09/06/07:41:36.085 muq:127.000.000.001:40000 job:7360000015 user:root             msg: xy-oldmud2.muf: Accepting logins...
date:1998/09/06/07:41:36.261 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:36.262 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:36.285 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: oldmud:daemon: starting up.

date:1998/09/06/07:41:36.286 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:38.457 muq:198.161.029.208:30000 job:b060000015 user:root             msg: 1943-millisec garbage collect #1 recovered 398 objects 1759221 bytes, left 20678 objects, 5564944 bytes
date:1998/09/06/07:41:38.943 muq:198.161.029.208:30000 job:b060000015 user:root             msg: xx-oldmud2 starting...
date:1998/09/06/07:41:39.375 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Starting muqnet...

date:1998/09/06/07:41:39.383 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet:run Starting up.
date:1998/09/06/07:41:39.392 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Making sample isle...
date:1998/09/06/07:41:39.446 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Making sample users...
date:1998/09/06/07:41:39.821 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 340-millisec exptmod done

date:1998/09/06/07:41:40.256 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 368-millisec exptmod done
date:1998/09/06/07:41:41.549 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 1244-millisec garbage collect #2 recovered 359 objects 53540 bytes, left 21199 objects, 6016082 bytes
date:1998/09/06/07:41:41.574 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Starting isle daemons...
date:1998/09/06/07:41:41.579 muq:127.000.000.001:30000 job:8260000015 user:foreplay         msg: oldmud:daemon: starting up.

date:1998/09/06/07:41:41.581 muq:127.000.000.001:30000 job:7e60000015 user:forestay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:46.626 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Done 5-sec sleep...
date:1998/09/06/07:41:46.632 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:47.947 muq:127.000.000.001:30000 job:b060000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-320258305700956420 delay=1000

date:1998/09/06/07:41:47.948 muq:127.000.000.001:30000 job:b060000015 user:root             msg: ]request/aaa taskId = -320258305700956420
date:1998/09/06/07:41:48.045 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 353-millisec exptmod done
date:1998/09/06/07:41:51.165 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 382-millisec exptmod done
date:1998/09/06/07:41:51.171 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckMuqnetUserInfo: Updating muqnet hashname 1135673582552223300
date:1998/09/06/07:41:51.172 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf started isle daemons...

date:1998/09/06/07:41:51.179 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf: Accepting logins...
date:1998/09/06/07:41:47.947 muq:127.000.000.001:30000 job:b060000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-320258305700956420 delay=1000
date:1998/09/06/07:41:51.496 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]requestTimeoutFn/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-320258305700956420 delay=1000
date:1998/09/06/07:41:51.496 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: task:requestTimeoutFn oldmud:REQ_PREV_LIST_ENTRY no response, retrying: task id -320258305700956420
date:1998/09/06/07:41:51.637 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 454-millisec exptmod done
date:1998/09/06/07:41:52.293 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 769-millisec exptmod done

date:1998/09/06/07:41:52.296 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet: Packet from unknown hashname 1484424047586484190, dropping packet & requesting info

date:1998/09/06/07:41:52.302 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckMuqnetUserInfo: Updating muqnet hashname 1135673582552223300
date:1998/09/06/07:41:52.729 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:52.731 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: oldmud:daemon: starting up.
date:1998/09/06/07:41:52.915 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 605-millisec exptmod done
date:1998/09/06/07:41:52.918 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 1484424047586484190 (foregroundRoot)
date:1998/09/06/07:41:53.283 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 363-millisec exptmod done
date:1998/09/06/07:41:53.365 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet: Packet mentions unknown hashname 717454048967077874, dropping packet & requesting info

date:1998/09/06/07:41:53.918 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 334-millisec exptmod done

date:1998/09/06/07:41:54.268 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 343-millisec exptmod done
date:1998/09/06/07:41:54.271 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 717454048967077874 (backgroundRoot)
date:1998/09/06/07:41:55.581 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956416

date:1998/09/06/07:41:56.201 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 617-millisec exptmod done
date:1998/09/06/07:41:56.675 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_ISLE_QUAY taskId=-320258305700956415 delay=1000
date:1998/09/06/07:41:56.675 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956415
date:1998/09/06/07:41:56.679 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-320258305700956414 delay=1000

date:1998/09/06/07:41:56.679 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956414
date:1998/09/06/07:41:55.580 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_ADD_TO_LIST taskId=-320258305700956416 delay=1000
date:1998/09/06/07:41:56.682 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]requestTimeoutFn/aaa op=oldmud:REQ_ADD_TO_LIST taskId=-320258305700956416 delay=1000
date:1998/09/06/07:41:56.683 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: task:requestTimeoutFn oldmud:REQ_ADD_TO_LIST no response, retrying: task id -320258305700956416
date:1998/09/06/07:41:56.753 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 545-millisec exptmod done
date:1998/09/06/07:41:56.904 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_ADD_TO_LIST taskId=-1286133147142494090 delay=1000
date:1998/09/06/07:41:56.904 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494090
date:1998/09/06/07:41:57.032 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_ISLE_QUAY taskId=-1286133147142494089 delay=1000

date:1998/09/06/07:41:57.032 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494089
date:1998/09/06/07:41:57.095 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1286133147142494088 delay=1000
date:1998/09/06/07:41:57.096 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494088
date:1998/09/06/07:41:57.127 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-320258305700956413 delay=1000

date:1998/09/06/07:41:57.127 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956413
date:1998/09/06/07:41:57.134 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-320258305700956412 delay=1000
date:1998/09/06/07:41:57.135 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956412
date:1998/09/06/07:41:57.137 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-320258305700956411 delay=1000

date:1998/09/06/07:41:57.137 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956411
date:1998/09/06/07:41:57.139 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-320258305700956410 delay=1000
date:1998/09/06/07:41:57.140 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956410
date:1998/09/06/07:41:57.142 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-320258305700956409 delay=1000

date:1998/09/06/07:41:57.142 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956409
date:1998/09/06/07:41:57.158 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-320258305700956408 delay=1000
date:1998/09/06/07:41:57.159 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956408
date:1998/09/06/07:41:57.163 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-320258305700956407 delay=1000

date:1998/09/06/07:41:57.164 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956407
date:1998/09/06/07:41:57.168 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-320258305700956406 delay=1000
date:1998/09/06/07:41:57.168 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956406
date:1998/09/06/07:41:57.173 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-320258305700956405 delay=1000

date:1998/09/06/07:41:57.173 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956405
date:1998/09/06/07:41:57.220 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1286133147142494087 delay=1000

date:1998/09/06/07:41:57.220 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494087
date:1998/09/06/07:41:57.224 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1286133147142494086 delay=1000
date:1998/09/06/07:41:57.225 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494086
date:1998/09/06/07:41:57.254 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-320258305700956404 delay=1000
date:1998/09/06/07:41:57.255 muq:127.000.000.001:30000 job:7a60000015 user:root             msg: ]request/aaa taskId = -320258305700956404
date:1998/09/06/07:41:57.265 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1286133147142494085 delay=1000

date:1998/09/06/07:41:57.266 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494085
date:1998/09/06/07:41:57.268 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1286133147142494084 delay=1000
date:1998/09/06/07:41:57.268 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494084
date:1998/09/06/07:41:57.294 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1286133147142494083 delay=1000

date:1998/09/06/07:41:57.294 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494083
date:1998/09/06/07:41:57.298 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1286133147142494082 delay=1000
date:1998/09/06/07:41:57.298 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494082
date:1998/09/06/07:41:57.328 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1286133147142494081 delay=1000

date:1998/09/06/07:41:57.328 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494081
date:1998/09/06/07:41:57.332 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1286133147142494080 delay=1000
date:1998/09/06/07:41:57.333 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494080
date:1998/09/06/07:41:57.337 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1286133147142494079 delay=1000

date:1998/09/06/07:41:57.338 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494079
date:1998/09/06/07:41:57.342 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1286133147142494078 delay=1000
date:1998/09/06/07:41:57.342 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494078
date:1998/09/06/07:42:00.666 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckMuqnetUserInfo: Updating muqnet hashname 1135673582552223300

date:1998/09/06/07:42:03.502 muq:127.000.000.001:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1141 (local port 30023)
date:1998/09/06/07:42:04.814 muq:127.000.000.001:30000 job:0260000015 user:root             msg: 1307-millisec garbage collect #3 recovered 500 objects 87658 bytes, left 21418 objects, 6471496 bytes
date:1998/09/06/07:42:05.110 muq:127.000.000.001:30000 job:0260000015 user:root             msg: Logged in: forestay.
date:1998/09/06/07:42:05.154 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1093355290817709975 delay=1000

date:1998/09/06/07:42:05.155 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709975
date:1998/09/06/07:42:05.157 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: oldmsh:]shell starting up.
date:1998/09/06/07:42:05.229 muq:127.000.000.001:30000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1142 (local port 30023)
date:1998/09/06/07:42:05.329 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1093355290817709974 delay=1000

date:1998/09/06/07:42:05.330 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709974
date:1998/09/06/07:42:05.344 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709973 delay=1000
date:1998/09/06/07:42:05.344 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709973

date:1998/09/06/07:42:05.347 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709972
date:1998/09/06/07:42:05.353 muq:127.000.000.001:30000 job:1560000015 user:root             msg: Logged in: foreplay.
date:1998/09/06/07:42:06.279 muq:127.000.000.001:30000 job:a960000015 user:root             msg: 923-millisec garbage collect #4 recovered 34 objects 73618 bytes, left 21510 objects, 6950592 bytes
date:1998/09/06/07:42:06.392 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709971 delay=1000

date:1998/09/06/07:42:06.393 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709971
date:1998/09/06/07:42:05.346 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709972 delay=1000
date:1998/09/06/07:42:06.395 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709972 delay=1000
date:1998/09/06/07:42:06.396 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_NTH_HOLDING no response, retrying: task id -1093355290817709972
date:1998/09/06/07:42:06.405 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351604 delay=1000

date:1998/09/06/07:42:06.405 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351604
date:1998/09/06/07:42:06.407 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: oldmsh:]shell starting up.
date:1998/09/06/07:42:06.779 muq:127.000.000.001:40000 job:           user:root             msg: TCP    CONNECT from 127,0.0.1:1143 (local port 40023)

date:1998/09/06/07:42:06.930 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351603 delay=1000
date:1998/09/06/07:42:06.931 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351603

date:1998/09/06/07:42:06.942 muq:127.000.000.001:40000 job:0c60000015 user:root             msg: Logged in: backstay.
date:1998/09/06/07:42:06.963 muq:127.000.000.001:40000 job:6e60000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1974017717718283042 delay=1000
date:1998/09/06/07:42:06.963 muq:127.000.000.001:40000 job:6e60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283042
date:1998/09/06/07:42:06.966 muq:127.000.000.001:40000 job:6e60000015 user:backstay         msg: oldmsh:]shell starting up.

date:1998/09/06/07:42:06.976 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1974017717718283041 delay=1000
date:1998/09/06/07:42:06.976 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283041
date:1998/09/06/07:42:06.986 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1974017717718283040 delay=1000
date:1998/09/06/07:42:06.986 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283040

date:1998/09/06/07:42:06.989 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1974017717718283039 delay=1000
date:1998/09/06/07:42:06.990 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283039
date:1998/09/06/07:42:07.003 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283038

*****
date:1998/09/06/07:42:07.003 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa          op=oldmud:REQ_IS_HELD_BY taskId=-1974017717718283038 delay=1000
date:1998/09/06/07:42:07.007 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1974017717718283038 delay=1000
date:1998/09/06/07:42:07.007 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1974017717718283038
date:1998/09/06/07:42:07.024 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351602 delay=1000
date:1998/09/06/07:42:07.025 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351602
date:1998/09/06/07:42:07.027 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351601 delay=1000
date:1998/09/06/07:42:07.027 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351601

date:1998/09/06/07:42:07.029 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351600 delay=1000
date:1998/09/06/07:42:07.030 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351600
date:1998/09/06/07:42:07.145 muq:127.000.000.001:40000 job:           user:backstay         msg: TCP    CONNECT from 127,0.0.1:1144 (local port 40023)
date:1998/09/06/07:42:07.160 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351599 delay=1000
date:1998/09/06/07:42:07.160 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351599

date:1998/09/06/07:42:07.165 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351598 delay=1000
date:1998/09/06/07:42:07.166 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351598
date:1998/09/06/07:42:07.472 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351597 delay=1000
date:1998/09/06/07:42:07.473 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351597

date:1998/09/06/07:42:07.479 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1093355290817709970 delay=1000
date:1998/09/06/07:42:07.480 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709970
date:1998/09/06/07:42:07.490 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709969 delay=1000
date:1998/09/06/07:42:07.490 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709969

date:1998/09/06/07:42:07.805 muq:127.000.000.001:40000 job:7860000015 user:root             msg: 623-millisec garbage collect #3 recovered 839 objects 110711 bytes, left 18725 objects, 4546516 bytes

date:1998/09/06/07:42:08.043 muq:127.000.000.001:40000 job:7860000015 user:root             msg: Logged in: backplay.
date:1998/09/06/07:42:08.065 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1007381179845897137 delay=1000
date:1998/09/06/07:42:08.065 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897137
date:1998/09/06/07:42:08.068 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: oldmsh:]shell starting up.

date:1998/09/06/07:42:08.102 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: muf:]shell starting up.
date:1998/09/06/07:42:08.191 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: muf:]shell exiting.
date:1998/09/06/07:42:08.501 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1007381179845897136 delay=1000
date:1998/09/06/07:42:08.502 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897136
date:1998/09/06/07:42:08.511 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897135 delay=1000
date:1998/09/06/07:42:08.511 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897135

date:1998/09/06/07:42:08.514 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897134 delay=1000
date:1998/09/06/07:42:08.515 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897134
date:1998/09/06/07:42:08.518 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897133 delay=1000
date:1998/09/06/07:42:08.518 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897133

date:1998/09/06/07:42:08.531 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897132 delay=1000
date:1998/09/06/07:42:08.532 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897132
date:1998/09/06/07:42:08.608 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897131 delay=1000
date:1998/09/06/07:42:08.609 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897131

date:1998/09/06/07:42:08.627 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1007381179845897130 delay=1000
date:1998/09/06/07:42:08.628 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897130
date:1998/09/06/07:42:08.636 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1974017717718283037 delay=1000
date:1998/09/06/07:42:08.636 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283037

date:1998/09/06/07:42:08.646 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1974017717718283036 delay=1000
date:1998/09/06/07:42:08.646 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283036
date:1998/09/06/07:42:09.453 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709968 delay=1000
date:1998/09/06/07:42:09.453 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709968

date:1998/09/06/07:42:09.456 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709967 delay=1000
date:1998/09/06/07:42:09.457 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709967
date:1998/09/06/07:42:09.553 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709966 delay=1000
date:1998/09/06/07:42:09.554 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709966

date:1998/09/06/07:42:09.557 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709965
date:1998/09/06/07:42:09.563 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709964

date:1998/09/06/07:42:09.566 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709963
date:1998/09/06/07:42:09.923 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 349-millisec exptmod done
date:1998/09/06/07:42:09.926 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet: Packet from unknown hashname 44568557447776376, dropping packet & requesting info
date:1998/09/06/07:42:10.297 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 365-millisec exptmod done

date:1998/09/06/07:42:10.620 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709962 delay=1000
date:1998/09/06/07:42:10.621 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709962
date:1998/09/06/07:42:10.623 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709961 delay=1000
date:1998/09/06/07:42:10.624 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709961

date:1998/09/06/07:42:09.557 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709965 delay=1000
date:1998/09/06/07:42:10.626 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709965 delay=1000
date:1998/09/06/07:42:10.627 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_WHO_USER_INFO no response, retrying: task id -1093355290817709965
date:1998/09/06/07:42:09.562 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709964 delay=1000
date:1998/09/06/07:42:10.629 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709964 delay=1000
date:1998/09/06/07:42:10.630 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_PREV_LIST_ENTRY no response, retrying: task id -1093355290817709964

date:1998/09/06/07:42:09.565 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709963 delay=1000
date:1998/09/06/07:42:10.633 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709963 delay=1000
date:1998/09/06/07:42:10.634 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_PREV_LIST_ENTRY no response, retrying: task id -1093355290817709963
date:1998/09/06/07:42:10.811 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 509-millisec exptmod done

date:1998/09/06/07:42:10.814 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 44568557447776376 (forestay)
date:1998/09/06/07:42:11.185 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 334-millisec exptmod done
date:1998/09/06/07:42:11.263 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet: Packet mentions unknown hashname 1177204252593023188, dropping packet & requesting info
date:1998/09/06/07:42:11.701 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 354-millisec exptmod done
date:1998/09/06/07:42:12.407 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 699-millisec exptmod done

date:1998/09/06/07:42:12.411 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 1177204252593023188 (backplay)
date:1998/09/06/07:42:09.562 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709964 delay=1000
date:1998/09/06/07:42:12.413 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709964 delay=1000
date:1998/09/06/07:42:12.414 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_PREV_LIST_ENTRY no response, retrying: task id -1093355290817709964

date:1998/09/06/07:42:12.430 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709960
date:1998/09/06/07:42:12.433 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709959 delay=1000
date:1998/09/06/07:42:12.433 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709959
date:1998/09/06/07:42:12.814 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 374-millisec exptmod done

date:1998/09/06/07:42:13.236 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet: Packet mentions unknown hashname 735893151692068731, dropping packet & requesting info
date:1998/09/06/07:42:13.322 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 461-millisec exptmod done

date:1998/09/06/07:42:13.695 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 369-millisec exptmod done
date:1998/09/06/07:42:14.047 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 347-millisec exptmod done
date:1998/09/06/07:42:14.051 muq:127.000.000.001:30000 job:8760000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 735893151692068731 (backstay)
date:1998/09/06/07:42:12.429 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709960 delay=1000
date:1998/09/06/07:42:14.054 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709960 delay=1000

date:1998/09/06/07:42:14.055 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_PREV_LIST_ENTRY no response, retrying: task id -1093355290817709960
date:1998/09/06/07:42:14.058 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709959 delay=1000
date:1998/09/06/07:42:14.059 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_WHO_USER_INFO no response, retrying: task id -1093355290817709959
date:1998/09/06/07:42:14.159 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_PREV_LIST_ENTRY taskId=-1093355290817709958 delay=1000

date:1998/09/06/07:42:14.159 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709958
date:1998/09/06/07:42:14.162 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_WHO_USER_INFO taskId=-1093355290817709957 delay=1000
date:1998/09/06/07:42:14.163 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709957
date:1998/09/06/07:42:14.521 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 346-millisec exptmod done

date:1998/09/06/07:42:14.904 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 379-millisec exptmod done
date:1998/09/06/07:42:15.584 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1093355290817709956 delay=1000
date:1998/09/06/07:42:15.585 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709956
date:1998/09/06/07:42:15.792 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1093355290817709955 delay=1000
date:1998/09/06/07:42:15.793 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709955

date:1998/09/06/07:42:15.801 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709954 delay=1000
date:1998/09/06/07:42:15.802 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709954
date:1998/09/06/07:42:15.804 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1093355290817709953 delay=1000
date:1998/09/06/07:42:15.804 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709953

date:1998/09/06/07:42:16.738 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 836-millisec garbage collect #5 recovered 727 objects 118390 bytes, left 22332 objects, 7333046 bytes
date:1998/09/06/07:42:16.807 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1093355290817709952 delay=1000
date:1998/09/06/07:42:16.808 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709952
date:1998/09/06/07:42:16.858 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1093355290817709951 delay=1000

date:1998/09/06/07:42:16.858 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709951
date:1998/09/06/07:42:17.201 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1093355290817709950 delay=1000
date:1998/09/06/07:42:17.201 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709950
date:1998/09/06/07:42:17.207 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351596 delay=1000

date:1998/09/06/07:42:17.207 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351596
date:1998/09/06/07:42:17.483 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HEAR_WHISPER taskId=-1093355290817709949 delay=1000
date:1998/09/06/07:42:17.484 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709949
date:1998/09/06/07:42:17.489 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351595 delay=1000

date:1998/09/06/07:42:17.490 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351595
date:1998/09/06/07:42:18.105 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351594 delay=1000
date:1998/09/06/07:42:18.105 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351594
date:1998/09/06/07:42:18.110 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351593 delay=1000

date:1998/09/06/07:42:18.110 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351593
date:1998/09/06/07:42:18.117 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709948 delay=1000
date:1998/09/06/07:42:18.119 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709948
date:1998/09/06/07:42:18.131 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351592 delay=1000

date:1998/09/06/07:42:18.131 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351592
date:1998/09/06/07:42:18.142 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351591 delay=1000
date:1998/09/06/07:42:18.143 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351591
date:1998/09/06/07:42:18.150 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351590 delay=1000

date:1998/09/06/07:42:18.151 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351590
date:1998/09/06/07:42:18.154 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351589 delay=1000
date:1998/09/06/07:42:18.154 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351589
date:1998/09/06/07:42:18.162 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351588 delay=1000

date:1998/09/06/07:42:18.162 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351588
date:1998/09/06/07:42:18.242 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709947 delay=1000
date:1998/09/06/07:42:18.243 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709947
date:1998/09/06/07:42:18.250 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351587 delay=1000

date:1998/09/06/07:42:18.251 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351587
date:1998/09/06/07:42:18.253 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351586 delay=1000
date:1998/09/06/07:42:18.254 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351586
date:1998/09/06/07:42:18.256 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351585 delay=1000

date:1998/09/06/07:42:18.256 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351585
date:1998/09/06/07:42:18.258 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351584 delay=1000
date:1998/09/06/07:42:18.259 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351584
date:1998/09/06/07:42:18.261 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351583 delay=1000

date:1998/09/06/07:42:18.261 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351583
date:1998/09/06/07:42:18.288 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351582 delay=1000
date:1998/09/06/07:42:18.288 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351582
date:1998/09/06/07:42:18.293 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351581 delay=1000

date:1998/09/06/07:42:18.294 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351581
date:1998/09/06/07:42:18.298 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351580 delay=1000
date:1998/09/06/07:42:18.299 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351580
date:1998/09/06/07:42:18.304 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351579 delay=1000

date:1998/09/06/07:42:18.304 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351579
date:1998/09/06/07:42:18.910 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HEAR_PAGE taskId=-1093355290817709946 delay=1000
date:1998/09/06/07:42:18.911 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709946
date:1998/09/06/07:42:18.916 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351578 delay=1000

date:1998/09/06/07:42:18.917 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351578
date:1998/09/06/07:42:19.136 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_FIND_LIST_ENTRY taskId=-1093355290817709945 delay=1000
date:1998/09/06/07:42:19.136 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709945
date:1998/09/06/07:42:19.235 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HEAR_PAGE taskId=-1093355290817709944 delay=1000

date:1998/09/06/07:42:19.236 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709944
date:1998/09/06/07:42:19.244 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_FIND_LIST_ENTRY taskId=-1007381179845897129 delay=1000
date:1998/09/06/07:42:19.245 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897129

date:1998/09/06/07:42:19.605 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 355-millisec exptmod done
date:1998/09/06/07:42:20.088 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 430-millisec exptmod done
date:1998/09/06/07:42:20.100 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1007381179845897128 delay=1000
date:1998/09/06/07:42:20.100 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897128
date:1998/09/06/07:42:21.877 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1093355290817709943 delay=1000
date:1998/09/06/07:42:21.878 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709943

date:1998/09/06/07:42:21.887 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1093355290817709942 delay=1000
date:1998/09/06/07:42:21.888 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709942
date:1998/09/06/07:42:21.897 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1093355290817709941 delay=1000
date:1998/09/06/07:42:21.897 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709941

date:1998/09/06/07:42:21.905 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1093355290817709940 delay=1000
date:1998/09/06/07:42:21.905 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709940
date:1998/09/06/07:42:21.914 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1093355290817709939 delay=1000
date:1998/09/06/07:42:21.914 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709939

date:1998/09/06/07:42:21.966 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709938 delay=1000
date:1998/09/06/07:42:21.967 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709938
date:1998/09/06/07:42:21.969 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709937 delay=1000
date:1998/09/06/07:42:21.969 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709937

date:1998/09/06/07:42:21.971 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709936 delay=1000
date:1998/09/06/07:42:21.972 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709936
date:1998/09/06/07:42:21.974 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709935 delay=1000
date:1998/09/06/07:42:21.975 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709935

date:1998/09/06/07:42:21.977 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709934 delay=1000
date:1998/09/06/07:42:21.977 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709934
date:1998/09/06/07:42:21.979 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709933 delay=1000
date:1998/09/06/07:42:21.979 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709933

date:1998/09/06/07:42:22.004 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709932
*****
date:1998/09/06/07:42:22.003 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa          op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709932 delay=1000
date:1998/09/06/07:42:22.006 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709932 delay=1000
date:1998/09/06/07:42:22.007 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1093355290817709932

date:1998/09/06/07:42:22.012 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709931 delay=1000
date:1998/09/06/07:42:22.013 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709931
date:1998/09/06/07:42:22.017 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709930 delay=1000
date:1998/09/06/07:42:22.018 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709930

date:1998/09/06/07:42:22.023 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709929 delay=1000
date:1998/09/06/07:42:22.023 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709929
date:1998/09/06/07:42:22.028 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709928 delay=1000
date:1998/09/06/07:42:22.028 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709928

date:1998/09/06/07:42:22.083 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1093355290817709927 delay=1000
date:1998/09/06/07:42:22.084 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709927
date:1998/09/06/07:42:22.563 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1434772747578351577 delay=1000
date:1998/09/06/07:42:22.564 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351577

date:1998/09/06/07:42:22.574 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351576 delay=1000
date:1998/09/06/07:42:22.574 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351576
date:1998/09/06/07:42:23.148 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1007381179845897127 delay=1000

date:1998/09/06/07:42:23.149 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897127
date:1998/09/06/07:42:23.153 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1007381179845897126 delay=1000
date:1998/09/06/07:42:23.154 muq:127.000.000.001:40000 job:7a60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897126
date:1998/09/06/07:42:23.158 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1974017717718283035 delay=1000

date:1998/09/06/07:42:23.159 muq:127.000.000.001:40000 job:6c60000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283035
date:1998/09/06/07:42:23.171 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1007381179845897125 delay=1000
date:1998/09/06/07:42:23.172 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897125
date:1998/09/06/07:42:23.182 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1007381179845897124 delay=1000

date:1998/09/06/07:42:23.183 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897124
date:1998/09/06/07:42:23.190 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1007381179845897123 delay=1000
date:1998/09/06/07:42:23.190 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897123
date:1998/09/06/07:42:23.195 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1007381179845897122 delay=1000

date:1998/09/06/07:42:23.195 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897122
date:1998/09/06/07:42:23.203 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1007381179845897121 delay=1000
date:1998/09/06/07:42:23.204 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897121
date:1998/09/06/07:42:23.212 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1974017717718283034 delay=1000

date:1998/09/06/07:42:23.212 muq:127.000.000.001:40000 job:4360000015 user:backstay         msg: ]request/aaa taskId = -1974017717718283034
date:1998/09/06/07:42:23.227 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897120 delay=1000
date:1998/09/06/07:42:23.227 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897120
date:1998/09/06/07:42:23.232 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897119 delay=1000

date:1998/09/06/07:42:23.232 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897119
date:1998/09/06/07:42:23.235 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897118 delay=1000
date:1998/09/06/07:42:23.236 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897118
date:1998/09/06/07:42:23.240 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897117 delay=1000

date:1998/09/06/07:42:23.241 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897117
date:1998/09/06/07:42:23.244 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1007381179845897116 delay=1000
date:1998/09/06/07:42:23.244 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897116
date:1998/09/06/07:42:23.265 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897115 delay=1000

date:1998/09/06/07:42:23.265 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897115
date:1998/09/06/07:42:23.271 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897114 delay=1000
date:1998/09/06/07:42:23.272 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897114
date:1998/09/06/07:42:23.275 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897113 delay=1000

date:1998/09/06/07:42:23.275 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897113
date:1998/09/06/07:42:23.282 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897112 delay=1000
date:1998/09/06/07:42:23.282 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897112
date:1998/09/06/07:42:24.265 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351575 delay=1000
date:1998/09/06/07:42:24.266 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351575

date:1998/09/06/07:42:24.270 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351574 delay=1000
date:1998/09/06/07:42:24.270 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351574
date:1998/09/06/07:42:24.275 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709926 delay=1000
date:1998/09/06/07:42:24.276 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709926

date:1998/09/06/07:42:24.288 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351573
date:1998/09/06/07:42:24.979 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 679-millisec exptmod done
date:1998/09/06/07:42:24.983 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet: Packet from unknown hashname 823942959770310812, dropping packet & requesting info

date:1998/09/06/07:42:25.514 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 523-millisec exptmod done

date:1998/09/06/07:42:24.288 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa          op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351573 delay=1000
date:1998/09/06/07:42:25.865 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351573 delay=1000
date:1998/09/06/07:42:26.529 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: task:requestTimeoutFn oldmud:REQ_ROOM_BY_NAME no response, retrying: task id -1434772747578351573
date:1998/09/06/07:42:26.009 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 490-millisec exptmod done
date:1998/09/06/07:42:26.537 muq:127.000.000.001:40000 job:6860000015 user:root             msg: muqnet/doAckGetUserInfo: Updating guest hashname 823942959770310812 (foreplay)
date:1998/09/06/07:42:26.936 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 359-millisec exptmod done
date:1998/09/06/07:42:27.019 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351572 delay=1000
date:1998/09/06/07:42:27.019 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351572

date:1998/09/06/07:42:27.176 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351571 delay=1000
date:1998/09/06/07:42:27.176 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351571
date:1998/09/06/07:42:27.180 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351570 delay=1000
date:1998/09/06/07:42:27.181 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351570

date:1998/09/06/07:42:27.189 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351569 delay=1000
date:1998/09/06/07:42:27.189 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351569
date:1998/09/06/07:42:27.203 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709925 delay=1000
date:1998/09/06/07:42:27.203 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709925

date:1998/09/06/07:42:27.275 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351568 delay=1000
date:1998/09/06/07:42:27.275 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351568
date:1998/09/06/07:42:27.278 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351567 delay=1000
date:1998/09/06/07:42:27.278 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351567

date:1998/09/06/07:42:27.281 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351566 delay=1000
date:1998/09/06/07:42:27.281 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351566
date:1998/09/06/07:42:27.284 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351565 delay=1000
date:1998/09/06/07:42:27.284 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351565

date:1998/09/06/07:42:27.286 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351564 delay=1000
date:1998/09/06/07:42:27.287 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351564
date:1998/09/06/07:42:27.289 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351563 delay=1000
date:1998/09/06/07:42:27.290 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351563

date:1998/09/06/07:42:27.386 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351562 delay=1000
date:1998/09/06/07:42:27.386 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351562
date:1998/09/06/07:42:27.433 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351561 delay=1000
date:1998/09/06/07:42:27.434 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351561

date:1998/09/06/07:42:27.448 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351560 delay=1000
date:1998/09/06/07:42:27.448 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351560
date:1998/09/06/07:42:27.462 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351559 delay=1000
date:1998/09/06/07:42:27.463 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351559

date:1998/09/06/07:42:27.478 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351558
date:1998/09/06/07:42:27.939 muq:127.000.000.001:30000 job:8760000015 user:root             msg: 455-millisec exptmod done
date:1998/09/06/07:42:28.506 muq:127.000.000.001:40000 job:6860000015 user:root             msg: 563-millisec exptmod done

date:1998/09/06/07:42:27.477 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa          op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351558 delay=1000
date:1998/09/06/07:42:28.514 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351558 delay=1000

date:1998/09/06/07:42:28.515 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1434772747578351558
date:1998/09/06/07:42:28.523 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351557
date:1998/09/06/07:42:28.673 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1007381179845897111 delay=1000
date:1998/09/06/07:42:28.674 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897111
date:1998/09/06/07:42:28.683 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897110

date:1998/09/06/07:42:28.682 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa          op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897110 delay=1000
date:1998/09/06/07:42:29.723 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897110 delay=1000
date:1998/09/06/07:42:29.724 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1007381179845897110
date:1998/09/06/07:42:30.888 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897110 delay=1000
date:1998/09/06/07:42:30.889 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1007381179845897110

date:1998/09/06/07:42:31.935 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897110 delay=1000
date:1998/09/06/07:42:31.935 muq:127.000.000.001:40000 job:3660000015 user:backplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1007381179845897110
date:1998/09/06/07:42:32.950 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 4136-millisec garbage collect #6 recovered 3490 objects 423436 bytes, left 22961 objects, 7409629 bytes

date:1998/09/06/07:42:32.985 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897110 delay=1000
date:1998/09/06/07:42:32.986 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1007381179845897110

date:1998/09/06/07:42:28.523 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa          op=oldmud:REQ_HAS_COME taskId=-1434772747578351557 delay=1000
date:1998/09/06/07:42:32.001 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351557 delay=1000
date:1998/09/06/07:42:32.002 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: task:requestTimeoutFn oldmud:REQ_HAS_COME no response, retrying: task id -1434772747578351557
date:1998/09/06/07:42:33.331 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351556 delay=1000
date:1998/09/06/07:42:33.332 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351556

date:1998/09/06/07:42:33.386 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351555 delay=1000
date:1998/09/06/07:42:33.387 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351555
date:1998/09/06/07:42:33.389 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351554 delay=1000
date:1998/09/06/07:42:33.390 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351554

date:1998/09/06/07:42:33.602 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351553 delay=1000
date:1998/09/06/07:42:33.603 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351553
date:1998/09/06/07:42:33.619 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351552 delay=1000
date:1998/09/06/07:42:33.619 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351552

date:1998/09/06/07:42:33.790 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351551 delay=1000
date:1998/09/06/07:42:33.790 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351551
date:1998/09/06/07:42:33.829 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1007381179845897109 delay=1000
date:1998/09/06/07:42:33.829 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897109
date:1998/09/06/07:42:34.175 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_WHISPER taskId=-1434772747578351550 delay=1000
date:1998/09/06/07:42:34.176 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351550

date:1998/09/06/07:42:34.189 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1007381179845897108 delay=1000
date:1998/09/06/07:42:34.189 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897108

date:1998/09/06/07:42:34.788 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351549 delay=1000
date:1998/09/06/07:42:34.789 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351549
date:1998/09/06/07:42:34.793 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351548 delay=1000
date:1998/09/06/07:42:34.793 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351548

date:1998/09/06/07:42:34.802 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1007381179845897107 delay=1000
date:1998/09/06/07:42:34.802 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897107
date:1998/09/06/07:42:34.823 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351547 delay=1000
date:1998/09/06/07:42:34.824 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351547
date:1998/09/06/07:42:34.837 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351546 delay=1000
date:1998/09/06/07:42:34.838 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351546

date:1998/09/06/07:42:34.845 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351545 delay=1000
date:1998/09/06/07:42:34.845 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351545
date:1998/09/06/07:42:34.850 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351544 delay=1000
date:1998/09/06/07:42:34.850 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351544

date:1998/09/06/07:42:34.858 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351543 delay=1000
date:1998/09/06/07:42:34.859 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351543
date:1998/09/06/07:42:34.916 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1007381179845897106 delay=1000
date:1998/09/06/07:42:34.917 muq:127.000.000.001:40000 job:3b60000015 user:backplay         msg: ]request/aaa taskId = -1007381179845897106

date:1998/09/06/07:42:34.929 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351542 delay=1000
date:1998/09/06/07:42:34.929 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351542

date:1998/09/06/07:42:34.932 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351541 delay=1000
date:1998/09/06/07:42:34.932 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351541
date:1998/09/06/07:42:34.934 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351540 delay=1000
date:1998/09/06/07:42:34.935 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351540

date:1998/09/06/07:42:34.937 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351539 delay=1000
date:1998/09/06/07:42:34.937 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351539
date:1998/09/06/07:42:34.939 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351538 delay=1000
date:1998/09/06/07:42:34.940 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351538

date:1998/09/06/07:42:34.942 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351537 delay=1000
date:1998/09/06/07:42:34.942 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351537
date:1998/09/06/07:42:34.981 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351536 delay=1000
date:1998/09/06/07:42:34.981 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351536

date:1998/09/06/07:42:34.986 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351535 delay=1000
date:1998/09/06/07:42:34.987 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351535
date:1998/09/06/07:42:34.991 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351534 delay=1000
date:1998/09/06/07:42:34.992 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351534

date:1998/09/06/07:42:34.997 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351533 delay=1000
date:1998/09/06/07:42:34.997 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351533
date:1998/09/06/07:42:34.002 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351532

date:1998/09/06/07:42:34.002 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa          op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351532 delay=1000
date:1998/09/06/07:42:35.004 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]requestTimeoutFn/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351532 delay=1000
date:1998/09/06/07:42:35.005 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: task:requestTimeoutFn oldmud:REQ_IS_HELD_BY no response, retrying: task id -1434772747578351532
date:1998/09/06/07:42:35.058 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351531 delay=1000
date:1998/09/06/07:42:35.059 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351531

date:1998/09/06/07:42:35.579 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1093355290817709924 delay=1000
date:1998/09/06/07:42:35.580 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709924
date:1998/09/06/07:42:35.590 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709923 delay=1000
date:1998/09/06/07:42:35.590 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709923

date:1998/09/06/07:42:35.923 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351530 delay=1000
date:1998/09/06/07:42:35.924 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351530
date:1998/09/06/07:42:35.927 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351529 delay=1000
date:1998/09/06/07:42:35.928 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351529

date:1998/09/06/07:42:35.933 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709922 delay=1000
date:1998/09/06/07:42:35.933 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709922
date:1998/09/06/07:42:35.945 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351528 delay=1000
date:1998/09/06/07:42:35.945 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351528

date:1998/09/06/07:42:35.956 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351527 delay=1000
date:1998/09/06/07:42:35.956 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351527
date:1998/09/06/07:42:35.964 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351526 delay=1000
date:1998/09/06/07:42:35.964 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351526

date:1998/09/06/07:42:35.968 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351525 delay=1000
date:1998/09/06/07:42:35.969 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351525
date:1998/09/06/07:42:35.978 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351524 delay=1000
date:1998/09/06/07:42:35.978 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351524

date:1998/09/06/07:42:36.029 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709921 delay=1000
date:1998/09/06/07:42:36.029 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709921
date:1998/09/06/07:42:36.037 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351523 delay=1000
date:1998/09/06/07:42:36.038 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351523

date:1998/09/06/07:42:36.040 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351522 delay=1000
date:1998/09/06/07:42:36.040 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351522
date:1998/09/06/07:42:36.058 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351521 delay=1000
date:1998/09/06/07:42:36.059 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351521

date:1998/09/06/07:42:36.606 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1093355290817709920 delay=1000
date:1998/09/06/07:42:36.607 muq:127.000.000.001:30000 job:7960000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709920
date:1998/09/06/07:42:36.614 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1093355290817709919 delay=1000
date:1998/09/06/07:42:36.614 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709919

date:1998/09/06/07:42:36.622 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1093355290817709918 delay=1000
date:1998/09/06/07:42:36.622 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709918
date:1998/09/06/07:42:36.629 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1093355290817709917 delay=1000
date:1998/09/06/07:42:36.630 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709917

date:1998/09/06/07:42:36.639 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1093355290817709916 delay=1000
date:1998/09/06/07:42:36.639 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709916
date:1998/09/06/07:42:36.693 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709915 delay=1000
date:1998/09/06/07:42:36.694 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709915

date:1998/09/06/07:42:36.696 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709914 delay=1000
date:1998/09/06/07:42:36.697 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709914
date:1998/09/06/07:42:36.699 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1093355290817709913 delay=1000
date:1998/09/06/07:42:36.699 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709913

date:1998/09/06/07:42:36.712 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709912 delay=1000
date:1998/09/06/07:42:36.712 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709912
date:1998/09/06/07:42:36.717 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709911 delay=1000
date:1998/09/06/07:42:36.717 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709911

date:1998/09/06/07:42:36.739 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1093355290817709910 delay=1000
date:1998/09/06/07:42:36.739 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709910
date:1998/09/06/07:42:37.079 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa op=oldmud:REQ_ADD_TO_LIST taskId=-1286133147142494077 delay=1000
date:1998/09/06/07:42:37.082 muq:127.000.000.001:40000 job:5a60000015 user:root             msg: ]request/aaa taskId = -1286133147142494077
date:1998/09/06/07:42:37.188 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1434772747578351520 delay=1000
date:1998/09/06/07:42:37.189 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351520

date:1998/09/06/07:42:37.198 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351519 delay=1000
date:1998/09/06/07:42:37.199 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351519
date:1998/09/06/07:42:37.357 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_CANONICAL_ROOM_NAME taskId=-1434772747578351518 delay=1000
date:1998/09/06/07:42:37.357 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351518

date:1998/09/06/07:42:37.368 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351517 delay=1000
date:1998/09/06/07:42:37.368 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351517
date:1998/09/06/07:42:37.375 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351516 delay=1000
date:1998/09/06/07:42:37.376 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351516

date:1998/09/06/07:42:37.379 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351515 delay=1000
date:1998/09/06/07:42:37.379 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351515
date:1998/09/06/07:42:37.385 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1434772747578351514 delay=1000
date:1998/09/06/07:42:37.385 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351514

date:1998/09/06/07:42:37.394 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1093355290817709909 delay=1000
date:1998/09/06/07:42:37.395 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709909
date:1998/09/06/07:42:37.444 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351513 delay=1000
date:1998/09/06/07:42:37.444 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351513

date:1998/09/06/07:42:37.456 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709908 delay=1000
date:1998/09/06/07:42:37.457 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709908
date:1998/09/06/07:42:37.788 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351512 delay=1000
date:1998/09/06/07:42:37.789 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351512

date:1998/09/06/07:42:37.796 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351511 delay=1000
date:1998/09/06/07:42:37.797 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351511
date:1998/09/06/07:42:37.799 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351510 delay=1000
date:1998/09/06/07:42:37.799 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351510

date:1998/09/06/07:42:38.012 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351509 delay=1000
date:1998/09/06/07:42:38.012 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351509
date:1998/09/06/07:42:38.016 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351508 delay=1000
date:1998/09/06/07:42:38.016 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351508

date:1998/09/06/07:42:38.023 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351507 delay=1000
date:1998/09/06/07:42:38.024 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351507
date:1998/09/06/07:42:38.031 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351506 delay=1000
date:1998/09/06/07:42:38.032 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351506

date:1998/09/06/07:42:38.039 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351505 delay=1000
date:1998/09/06/07:42:38.040 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351505
date:1998/09/06/07:42:38.043 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351504 delay=1000
date:1998/09/06/07:42:38.043 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351504

date:1998/09/06/07:42:38.049 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351503 delay=1000
date:1998/09/06/07:42:38.050 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351503
date:1998/09/06/07:42:38.060 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351502 delay=1000
date:1998/09/06/07:42:38.060 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351502

date:1998/09/06/07:42:38.062 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351501 delay=1000
date:1998/09/06/07:42:38.063 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351501
date:1998/09/06/07:42:38.074 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351500 delay=1000
date:1998/09/06/07:42:38.075 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351500

date:1998/09/06/07:42:38.089 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709907 delay=1000
date:1998/09/06/07:42:38.090 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709907
date:1998/09/06/07:42:38.094 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709906 delay=1000
date:1998/09/06/07:42:38.094 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709906

date:1998/09/06/07:42:38.514 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351499 delay=1000
date:1998/09/06/07:42:38.515 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351499
date:1998/09/06/07:42:38.526 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1434772747578351498 delay=1000
date:1998/09/06/07:42:38.527 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351498

date:1998/09/06/07:42:38.529 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351497 delay=1000
date:1998/09/06/07:42:38.530 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351497
date:1998/09/06/07:42:40.452 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351496 delay=1000
date:1998/09/06/07:42:40.452 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351496

date:1998/09/06/07:42:40.902 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351495 delay=1000
date:1998/09/06/07:42:40.902 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351495
date:1998/09/06/07:42:40.912 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351494 delay=1000
date:1998/09/06/07:42:40.913 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351494

date:1998/09/06/07:42:40.921 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351493 delay=1000
date:1998/09/06/07:42:40.922 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351493
date:1998/09/06/07:42:40.930 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351492 delay=1000
date:1998/09/06/07:42:40.930 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351492

date:1998/09/06/07:42:40.940 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351491 delay=1000
date:1998/09/06/07:42:40.940 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351491
date:1998/09/06/07:42:40.990 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351490 delay=1000
date:1998/09/06/07:42:40.990 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351490

date:1998/09/06/07:42:40.993 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351489 delay=1000
date:1998/09/06/07:42:40.993 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351489
date:1998/09/06/07:42:40.995 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351488 delay=1000
date:1998/09/06/07:42:40.996 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351488

date:1998/09/06/07:42:40.998 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351487 delay=1000
date:1998/09/06/07:42:40.999 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351487
date:1998/09/06/07:42:41.017 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351486 delay=1000
date:1998/09/06/07:42:41.018 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351486

date:1998/09/06/07:42:41.023 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351485 delay=1000
date:1998/09/06/07:42:41.023 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351485
date:1998/09/06/07:42:41.030 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351484 delay=1000
date:1998/09/06/07:42:41.031 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351484

date:1998/09/06/07:42:41.156 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351483 delay=1000
date:1998/09/06/07:42:41.156 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351483
date:1998/09/06/07:42:41.469 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1093355290817709905 delay=1000
date:1998/09/06/07:42:41.470 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709905

date:1998/09/06/07:42:41.491 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709904 delay=1000
date:1998/09/06/07:42:41.491 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709904
date:1998/09/06/07:42:45.061 muq:127.000.000.001:30000 job:b060000015 user:root             msg: 3376-millisec garbage collect #7 recovered 4068 objects 486872 bytes, left 23042 objects, 7424300 bytes
date:1998/09/06/07:42:45.142 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HEAR_SAY taskId=-1434772747578351482 delay=1000

date:1998/09/06/07:42:45.142 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351482
date:1998/09/06/07:42:45.147 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351481 delay=1000
date:1998/09/06/07:42:45.148 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351481
date:1998/09/06/07:42:45.157 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351480 delay=1000

date:1998/09/06/07:42:45.157 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351480
date:1998/09/06/07:42:45.168 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351479 delay=1000
date:1998/09/06/07:42:45.168 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351479
date:1998/09/06/07:42:45.176 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351478 delay=1000

date:1998/09/06/07:42:45.177 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351478
date:1998/09/06/07:42:45.180 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_LEFT taskId=-1434772747578351477 delay=1000
date:1998/09/06/07:42:45.181 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351477
date:1998/09/06/07:42:45.189 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351476 delay=1000

date:1998/09/06/07:42:45.190 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351476
date:1998/09/06/07:42:45.200 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351475 delay=1000
date:1998/09/06/07:42:45.201 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351475
date:1998/09/06/07:42:45.203 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351474 delay=1000

date:1998/09/06/07:42:45.203 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351474
date:1998/09/06/07:42:45.215 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351473 delay=1000
date:1998/09/06/07:42:45.216 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351473
date:1998/09/06/07:42:45.235 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_SUBSTRING taskId=-1093355290817709903 delay=1000

date:1998/09/06/07:42:45.235 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709903
date:1998/09/06/07:42:45.239 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709902 delay=1000
date:1998/09/06/07:42:45.240 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709902
date:1998/09/06/07:42:45.875 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351472 delay=1000

date:1998/09/06/07:42:45.875 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351472
date:1998/09/06/07:42:46.125 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_VIEW taskId=-1434772747578351471 delay=1000
date:1998/09/06/07:42:46.125 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351471
date:1998/09/06/07:42:46.742 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_EXIT_DESTINATION taskId=-1434772747578351470 delay=1000

date:1998/09/06/07:42:46.742 muq:127.000.000.001:30000 job:8660000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351470
date:1998/09/06/07:42:46.772 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ROOM_BY_NAME taskId=-1434772747578351469 delay=1000
date:1998/09/06/07:42:46.772 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351469
date:1998/09/06/07:42:46.780 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_ENHOLDING taskId=-1434772747578351468 delay=1000

date:1998/09/06/07:42:46.780 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351468
date:1998/09/06/07:42:46.787 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_DEHOLDING taskId=-1434772747578351467 delay=1000
date:1998/09/06/07:42:46.788 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351467
date:1998/09/06/07:42:46.796 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NUMBER_HOLDING taskId=-1434772747578351466 delay=1000

date:1998/09/06/07:42:46.797 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351466
date:1998/09/06/07:42:46.846 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351465 delay=1000
date:1998/09/06/07:42:46.846 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351465
date:1998/09/06/07:42:46.849 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351464 delay=1000

date:1998/09/06/07:42:46.849 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351464
date:1998/09/06/07:42:46.851 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351463 delay=1000
date:1998/09/06/07:42:46.852 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351463
date:1998/09/06/07:42:46.854 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_NTH_HOLDING taskId=-1434772747578351462 delay=1000

date:1998/09/06/07:42:46.854 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351462
date:1998/09/06/07:42:46.870 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351461 delay=1000
date:1998/09/06/07:42:46.871 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351461
date:1998/09/06/07:42:46.877 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351460 delay=1000

date:1998/09/06/07:42:46.878 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351460
date:1998/09/06/07:42:46.882 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1434772747578351459 delay=1000
date:1998/09/06/07:42:46.883 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351459
date:1998/09/06/07:42:46.988 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa op=oldmud:REQ_HAS_COME taskId=-1434772747578351458 delay=1000

date:1998/09/06/07:42:46.988 muq:127.000.000.001:30000 job:7460000015 user:foreplay         msg: ]request/aaa taskId = -1434772747578351458
date:1998/09/06/07:42:47.246 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HOLDING taskId=-1093355290817709901 delay=1000
date:1998/09/06/07:42:47.247 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709901
date:1998/09/06/07:42:47.256 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa op=oldmud:REQ_IS_HELD_BY taskId=-1093355290817709900 delay=1000

date:1998/09/06/07:42:47.257 muq:127.000.000.001:30000 job:7660000015 user:forestay         msg: ]request/aaa taskId = -1093355290817709900
date:1998/09/06/07:42:47.390 muq:127.000.000.001:30000 job:b060000015 user:root             msg: xx-oldmud2.muf Done.
date:1998/09/06/07:42:48.905 muq:127.000.000.001:30000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17422)
date:1998/09/06/07:42:49.085 muq:127.000.000.001:40000 job:           user:backplay         msg: TCP disconnect from 127,0.0.1:1144 (local port 40023)
date:1998/09/06/07:42:49.085 muq:127.000.000.001:40000 job:           user:backstay         msg: TCP disconnect from 127,0.0.1:1143 (local port 40023)

date:1998/09/06/07:43:00.717 muq:127.000.000.001:40000 job:0060000015 user:                 msg: STOPPING MUQ. (pid 17403)

/************************************************************************/
/*-    HISTORICAL SECTION						*/
/************************************************************************/

Everything below this point is of historical interest only.


/************************************************************************/
/*-    IN A NUTSHELL: PROBLEMS TO BE ADDRESSED				*/
/************************************************************************/

Micronesia already supports WAN-distributed operation.  The two chief deficiencies
to be addressed this time around are:

*  Current code provides no authentication beyond trusting IP packet headers:  It
   is ridiculously easy to spoof someone else.

*  Current code provides no abstraction away from IP:  If a server changes to another
   IP address or is running on a dynamic IP address that differs each time it reboots
   or such, the current system will fail badly.



/************************************************************************/
/*-    IN A NUTSHELL: PROPOSED SOLUTION					*/
/************************************************************************/


I've implemented long integers and Diffie-Hellman (DH) support: This
means each major agent (i.e., each human user, each major daemon, &tc)
can have DH based public/private keypairs, and thus can authenticate
itself via DH shared secrets.

Thus, I propose in essence:

*  Each major agent is identified in prinicple by its DH public key:
   Any entity able to prove it has the matching DH private key is to
   be considered a manifestation of that agent.

*  In practice, each major agent will most of the time be labelled
   by a 61-bit hash of its public key ("ID").  This is much more efficient
   to process, and shouldn't reduce security noticably over using the
   full public key.

*  Each Muq server will maintain a dictionary of known agents, including
   for each roughly:

     Public key
     Private key (if agent is local to the server).
     ID.  (Hash of public key.)
     I/O stream on which agent was last known to be accepting requests, as ipAddress:port:objref
     locationNumber: Incremented each time location is changed.
     3-5 location servers capable of providing agent's current I/O stream.
     Full text name of entity, if any, for human consumption.  (Max 256 chars.)
     Nickname of entity, if any, for human consumption.  (Max 16 chars.)
     Some sort of user/daemon/remoteuser object pointer...?
     Milliseconds since last querying location servers, to prevent thrashing? (only for remote agents).
     Shared secrets of agent with other agents, indexed by ID of those other agents.

   The dictionary will be indexed at minimum by ID.  Probably
   also by nickname, possibly by others.
   We will also need a way to find all local agents, so as to update their
   IP,port if server's IP,port change for any reason.  This probably means
   an index of just local agents, by ID.

   Per-dictionary fields likely needed:
     Milliseconds to wait before requerying location servers.

   ]request server probably needs to track number of retries done so far (I don't think
   this is done yet) and to have a parameter controlling number of retries before it
   tries re-resolving the target object's IP address via its location servers.

* Each Muq server is willing to serve entries from the above dictionariy on
  request.  Thus, it can serve as a location server:  Location servers need
  no special software.

* Each Muq server is willing to update entries in the above dictionary when
  presented by an appropriately authenticated request. (I.e., source of
  request demonstrates possession of matching private key.)



/************************************************************************/
/*-    EXISTING SUPPORT TO BE LEVERAGED					*/
/************************************************************************/


*  Micronesia has a #']request (?) facility for communicating with other
   Micronesia entities.  It does essentially what I want other than being
   too hardwired to specific IP addresses:  Should be possible to adapt
   it rather than replacing it.

*  Muqnet has existing support for passing packets back and forth between
   Muq servers, automatically converting values to proxies as needed:  Again,
   I think I can leverage this by adapting it rather than needing to rewrite it.

*  The above mentioned DH support.


/************************************************************************/
/*-    QUESTIONS TO BE RESOLVED						*/
/************************************************************************/


*  How does Micronesia work, exactly, at present?  In particular, where do we
   have hard IP addresses at present?  What is needed for ]request to work
   across dynamic addresses?
   ANSWERS:
   *  ]request per se isn't aware of IP addresses or machine boundaries;
      It simply sends to io streams, which may transparently be proxies
      rather than local streams.
   *  proxy objects contain hard IP addresses as ip[0-3],port.
      These need to change to first including ID also, then all code
      using ip[0-3],port needs to change to using ID + dictionary,
      then ip[0-3],port need to be deleted.

*  What should we do with proxies?  They currently have hard IP addresses.
   Do we just change these to IDs?  Of -what- is this the ID, then?  The
   Muqnet daemon?  Or?  Needs to be smallest unit of IP migration which
   we ever want to support, no?  This suggests making it the owner of the
   object.  This means, however, that we won't be able to change owner
   of an object once created.  Seems a reasonable cost to me, however.
   (The traditional mud @CHOWN can do a clone operation.  If the chown
   is between users on different servers, this is what you want anyhow.)

*  What is the order of implementation tasks?  What code will be affected
   by these changes?

*  Where do we find out our IP address?  How do we update all our
   local dictionary entries when we notice it has changed?
   ANSWER:
     c/sys.t:note_host_name_and_ip_address() is called at each bootup and
     generates this information from C gethostbyname() &tc calls.

*  Should we include 'obsoletes' and 'obsoletedBy' fields in agent records,
   to allow for dropping old public/private keypairs?

*  Should 'who' fields in messages be IDs, or usr objects for locals and
   remoteuser objects for remotes?
    [Thinkthinkthink]
   ANSWER: I really like the idea of having all 'agent records' and all
   'who' fields in messages be user objects, with a local/remote flag
   added to the user object.  This would make the world much simpler
   and uniform for local user and administration code alike, which would
   simply see everyone as a user record, whether they are local or remote.
   Hrm, possibly a bit -too- uniform, might let remote users slip through
   too many permission checks in the server.  Ok, a separate guest subclass,
   'gst' parallel to 'rot' and 'usr', but structurally identical.
     This means that ID fields would really be used as a primary name for
   a user only within packets travelling between servers, as a machine-
   independent identifier: At both ends, the ID would promptly be translated
   back into a user record.
     This also means that /u should work as an index of all local IDs which
   need updating when local IP address changes.  For the rest, I think mebbe
   /guests/byID and /guests/byNickname.  And I suppose
   /usersByID ?



/************************************************************************/
/*-    IMPLEMENTATION STRATEGY						*/
/************************************************************************/

/************************************************************************/
/*-    THOUGHT								*/
/************************************************************************/


It is noticable that many of the future-expansion things I'm trying to put
in are just data fields, since we can't easily add new fields without incurring
indirection overhead.  Is a canonical solution to this possible?
  Having the object table have a full disk address in it will of course solve
the problem:  We can relocate objects as needed to expand them.  But I very much
dislike expanding in-ram per-object overhead to 32 bits.
  If we presume a relatively small proportion of objects get expanded, we could
keep a hashed exception table of disk addresses?
  We're currently looking at handling redirection above the vm.c level, via object
indirection types.  Should we move this into the vm.c layer?  Then the indirection
could be hacked directly into the mmu table, and in-ram access to redirected objects
would be exactly as fast as to non-redirected objects -- only the initial disk fetch
would be slower, since presumably we would fetch, check, discover some redirection
flag, and refetch.  There are some garbage collection implications in how we keep both
disk cells marked as being use, and later have them both become free together when
garbage-collected.
  If we could solve this problem prettily, that would be a key distinction from Java.
  Given that we're not keeping enough info in-ram to encode a disk
address, putting the redirect on disk and paying an extra fetch
appears to be optimal?  Or could we treat each octave file as a
hashtable, store the octave in-ram, and keep the octave files empty
enough to be efficient hashtables?  This costs us x2 in disk space,
alas, which is a bit unpleasant, and it would also appear that
expanding an octave file would be expensive...?  Another hack would be
to use multiple hash functions (say 16) and record which one was used:
This might allow hash table to run more than 1/2 full, yet still have
a compact in-ram record?  The win would be maintaining single-read
access to any object, even if expanded.  We might wind up with several
implementations of the vm.c interface, catering to different desired
space-time trade-offs...?  Hiding indirection handling behind the vm.c
interface would make swapping implementations a lot easier than if we
did it above the vm.c interface.  This seems to mainly mean adding a
realloc() style call.


/************************************************************************/
/*-    DYNAMIC IP ADDRESS THOUGHTS, QUESTIONS, ANSWERS &tc		*/
/************************************************************************/

   
* STATUS, 99Jan11:  Just got userVersion included in all Guest(+User)
  records, and all muqnet packets.  Just added checks to muqnet daemon
  to ask for user info update if userVersion has changed.
    Just added user%s/email, user%s/homepage, user%s/pgpKeyprint,
  user%s/doNotDisturb and user%s/doing fields.

* AFTER THAT, should probably clean up the crypto situation by
  verifying that legal2.c is in muq-crypto-src, that they compile
  right, that it is downloaded and installed in the development
  source, and that the export version uses a simple-minded hash
  rather than SHA for authentication.

* We have a general problem with replies:  If we are replying to
  someone who has changed address, we won't notice if the
  answer fails to arrive.
    We should include the sender's user state number in each
  authenticated packet, both REQ and ACK.  Muqnet daemon should
  check the state number on each authenticated packet against that
  recorded in the Guest record:  If they do not match, it should
  fire off an update request.  (It need not, however, drop the packet.)

*  Q:  What dynamic-IP situations do we need to test?
   A:  Seems like we need to enumerate the basic interaction patterns
       possible, then enumerate what happens if each of the individual
       roles within that interaction fails due to changed IP address.

       (1) TYPICAL REQUEST:  A fires request to B, B returns reply to A.

       (2) UPDATE  REQUEST:  A asks B, packet passed to C, reply goes to A.

       In addition to the above failure-driven mode, we'd like some updates
       done proactively:

       (3) When A has moved, it must notify its location servers B.

       (4) A needs to notice in a timely way moves of its location
           servers B.

       (5) Any A interacting with B needs to note in a timely way any
           moved location servers C for B.

       * Handling 5: The only reasonable solution which occurs to me is to have
       replies in 1B include the fixnum version number from B.  1A can then
       routinely compare stored to received version, and request an update
       if they do not match.  (Since muqnet treats 1A and 1B symmetrically,
       we'll want to have all vanilla packets include the sender's generation
       number?)

       * Handling 4: I think the best solution is for:
         * Users to remember the generations of their location servers.
         * Users to check the above regularly, and update their own generation
           whenever a server generation changes.  This can be done by their
	   location server janitor task.
         * Users generate traffic to their location servers on a regular basis.
           Sending an update of their state at boot-up is one obvious way.
           If their location servers have moved, the normal retry logic will
	   then result in an update of the location server Guest record, which
           will be noticed by the above.
       their location servers periodically.  I don't expect location
       servers to move, in practice, so doing this once at boot up of
       the server should work fine as a first attempt.

       * Handling 3:  This is already taken care of, by having user daemons
         remember their server's location, compare against actual server
         location at user daemon boot time, and then update as appropriate.

       * We still need to add logic to handle 1.  Sending an update request
         to a randomly selected location server every 4th retry, say, would
         seem a workable approach.

       I still don't see a clear enumeration of cases, but that would seem
       likely to cover most cases in practice.

   For example, presumably we need to individually test each of the basic
   roles of the muqserver:
     User's primary server changes IP address.
     Location user is trying to access changes IP address.
     User's location server changes IP address.
   Do we not need a 3-server part of the regression suite to check these?
   How -do- we ever catch a location server changing address?  Do we need
   to poll them periodically?  Since the location servers only ever matter
   if -we- change address, it would seem to be sufficient to poll them
   when our daemon is rebooted, except perhaps for the risk of losing
   track of them entirely.

*  I think completing and checking out dynamic address support &tc should
   come next, while I still have fast 24-hour internet access.

Q:  Where are we currently storing IP addresses?
    Presumably just in Guest records?  (The current IP
    address must be available in /sys%s or something, but
    isn't stored in the db, right?)
     I'm tentatively supposing that what we need to do is
    to have both the muqnet daemon and the user daemons
    store 'last-known-IP-address' in their stable state,
    and then check that against the current IP address when
    they are restarted:  If there's a difference, they need
    to take appropriate actions and then update the last-known
    field. 

    * Current address is published in-db as:
	  /sys%s/ip0
	  /sys%s/ip1
	  /sys%s/ip2
	  /sys%s/ip3
	  /sys%s/muqPort

    * Guest objects have fields
	  usr%s/ip0
	  usr%s/ip1
	  usr%s/ip2
	  usr%s/ip3
	  usr%s/port
      These are currently on Guest (did I mean "User"?) 
      objects purely for uniformity, but could be used
      to cache last-known-address for the user daemon,
      as long as they are present.

    * User and Guest objects also have fields:
	Vm_Obj io_stream;	/* Last known I/O stream on which user	*/
				/* was accepting communications.	*/
				/* Next is non-NIL iff a user_server_*	*/
				/* is absent from /folkBy/hashName:	*/
	Vm_Obj has_unknown_user_server;

	Vm_Obj user_server_0;	/* Muqserver which should know our loc.	*/
	Vm_Obj user_server_1;	/* Muqserver which should know our loc.	*/
	Vm_Obj user_server_2;	/* Muqserver which should know our loc.	*/
	Vm_Obj user_server_3;	/* Muqserver which should know our loc.	*/
	Vm_Obj user_server_4;	/* Muqserver which should know our loc.	*/

	Vm_Obj user_server_1_needs_updating;/* NIL or date of last attempt.*/
	Vm_Obj user_server_2_needs_updating;/* NIL or date of last attempt.*/
	Vm_Obj user_server_3_needs_updating;/* NIL or date of last attempt.*/
	Vm_Obj user_server_4_needs_updating;/* NIL or date of last attempt.*/

				/* Used to help avoid thrashing servers:*/
	Vm_Obj date_at_which_we_last_queried_user_servers;
/* buggo?  Why does above need to be preserved across reboots? */
/* if it doesn't might was well make it a daemon local var, no? */

	Vm_Obj user_version;	/* Incremented each time ip[0-4],port	*/
				/* changed:  Used to decide which 	*/
				/* location server is most up-to-date,*/
				/* if they disagree.		*/

      -> Probably each time muqnet touches a Guest record, it should check
         the hasUnknownUserServers flag, and if set, check user_server_*
         and ask the Guest about at most one of them which are not in /folkBy.

      -> The user daemon should periodically check the *_needs_updating
         fields, and if they are set, fire off an update packet to that
         server (how?).  We probably need a throttle on this.

      -> The user daemon should at startup check its usr%s/ip[0-3]
         values against the /sys%s/ip[0-3] values:  If they differ, it
         should set all the usr%s/*needs_updating flags and then update
         its usr%s/ip[0-3].

Q:  What global internal db changes/actions are needed when we
    notice at boot that our IP address has changed?

      It isn't clear that we need do anything special at the network
      level.  But maybe we should have a user daemon running for
      our muqnet user -- are we currently doing this?  It would take
      care of propagating our new address to the location servers for
      muqnet itself.

      [LATER:]  From startup log, appears that user daemons run only
      for forestay + foreplay (&tc).
        We must not be actually creating avatars for root and muqnet. 
        But 490-W-root-oldmud:rootStartIsleDaemons IS starting some
        sort of daemons for:
          isle owner
          isle itself
        This raises the QUESTIONS:
        * What daemon code are these running?
        * Should they be uniformized by making them vanilla avatar daemons?
        * Are we winding up in these two cases with special-case addressable
            daemons which won't update their location servers properly without
            code duplication?
        ANSWERS:
	* The 'isle itself' 'daemon' appears in fact to merely be the
            370-W-oldisle.t:quayJanitorTask, which does housecleaning on
            the proas at regular intervals.  The relevant call merely
            starts up this task.
        * The 'isle owner' daemon is currently a oldmud:]daemon.
          So are the foreplay and forestay &tc daemons.  So we seem
          to have some uniformity there.
        * This appears to leave the 'muqnet' user accessible
          via muqnet, but without a running user daemon to keep its
          location servers updated and such.  Is there any reason not
          to just start up a daemon for it parallel to the one for root?


*  Need to update user daemons to check for location servers which need
   updating, and to do so as needed.  (I.e., location servers of OURS
   which haven't be updated to our current location.) Can we have them
   check for changed IP,port at start-up also, and handle updating their
   location servers?

*  Task daemon state probably needs new per-daemon field for:
   *  Retries before re-resolving ID -> IP:PORT.  (Subject to min millisecs between resolutions.)
   Task daemon state probably needs new per-task fields for:
   *  To as IP:port vs To as ID.
   *  Retries so far.
   [LATER]: We seem to have in fact eliminated IP:PORT from everywhere but Guest
   records -- a Good Thing.  All we probably need is logic to re-query location
   servers for the location of a given user after a certain number of timeouts,
   but before giving up entirely.  No?

*  Implement function to update IP,port for all local agents if bootup
   code notices local IP,port has changed.  Means we need a local copy
   of IP,port, bootup code that compares the two, code to update the
   location servers for a given user on request (does this mean we
   need a locationServerIsOutOfDate flag for each supported locationserver?)
   and code to invoke it on all local users (/u<*>).
    Note rootUpdateIPAddressesOfAllNatives is already written.
   Later: I'm currently thinking more of using the currently unused
   IP,port quintle on User objects, having them checked
   by the user daemon when it starts up.

*  Have added a hasUnknownUserServers flag on folk records:  Each time we
   recieve a packet signed by a guest, we should check this flag and if
   it is non-NIL, should check its location servers: non-NIL, non-zero
   values not present in /folkBy/hashName should then result in
   REQ_USER_INFO queries to that guest (who will forward them to the
   real server).  If there are no unknown location servers on the guest,
   the hasUnknownUserServers flag should be cleared.  Possibly the non-NIL
   value should be a date, and we should query only if a given amount of
   time has elapsed, to avoid thrashing guest's server?



/************************************************************************/
/*-    File variables							*/
/************************************************************************/
/*

Local variables:
mode: text
mode: outline-minor
outline-regexp: "[ \\t]*\/\\*-"
End:
*/
